// Code generated by terraform-plugin-framework-generator DO NOT EDIT.

package datasource_repository

import (
	"context"
	"fmt"
	"github.com/hashicorp/terraform-plugin-framework/attr"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-framework/types/basetypes"
	"github.com/hashicorp/terraform-plugin-go/tftypes"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/datasource/schema"
)

func RepositoryDataSourceSchema(ctx context.Context) schema.Schema {
	return schema.Schema{
		Attributes: map[string]schema.Attribute{
			"allow_fast_forward_only_merge": schema.BoolAttribute{
				Computed: true,
			},
			"allow_manual_merge": schema.BoolAttribute{
				Computed: true,
			},
			"allow_merge_commits": schema.BoolAttribute{
				Computed: true,
			},
			"allow_rebase": schema.BoolAttribute{
				Computed: true,
			},
			"allow_rebase_explicit": schema.BoolAttribute{
				Computed: true,
			},
			"allow_rebase_update": schema.BoolAttribute{
				Computed: true,
			},
			"allow_squash_merge": schema.BoolAttribute{
				Computed: true,
			},
			"archived": schema.BoolAttribute{
				Computed: true,
			},
			"archived_at": schema.StringAttribute{
				Computed: true,
			},
			"autodetect_manual_merge": schema.BoolAttribute{
				Computed: true,
			},
			"avatar_url": schema.StringAttribute{
				Computed: true,
			},
			"clone_url": schema.StringAttribute{
				Computed: true,
			},
			"created_at": schema.StringAttribute{
				Computed: true,
			},
			"default_allow_maintainer_edit": schema.BoolAttribute{
				Computed: true,
			},
			"default_branch": schema.StringAttribute{
				Computed: true,
			},
			"default_delete_branch_after_merge": schema.BoolAttribute{
				Computed: true,
			},
			"default_merge_style": schema.StringAttribute{
				Computed: true,
			},
			"description": schema.StringAttribute{
				Computed: true,
			},
			"empty": schema.BoolAttribute{
				Computed: true,
			},
			"external_tracker": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"external_tracker_format": schema.StringAttribute{
						Computed:            true,
						Description:         "External Issue Tracker URL Format. Use the placeholders {user}, {repo} and {index} for the username, repository name and issue index.",
						MarkdownDescription: "External Issue Tracker URL Format. Use the placeholders {user}, {repo} and {index} for the username, repository name and issue index.",
					},
					"external_tracker_regexp_pattern": schema.StringAttribute{
						Computed:            true,
						Description:         "External Issue Tracker issue regular expression",
						MarkdownDescription: "External Issue Tracker issue regular expression",
					},
					"external_tracker_style": schema.StringAttribute{
						Computed:            true,
						Description:         "External Issue Tracker Number Format, either `numeric`, `alphanumeric`, or `regexp`",
						MarkdownDescription: "External Issue Tracker Number Format, either `numeric`, `alphanumeric`, or `regexp`",
					},
					"external_tracker_url": schema.StringAttribute{
						Computed:            true,
						Description:         "URL of external issue tracker.",
						MarkdownDescription: "URL of external issue tracker.",
					},
				},
				CustomType: ExternalTrackerType{
					ObjectType: types.ObjectType{
						AttrTypes: ExternalTrackerValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "ExternalTracker represents settings for external tracker",
				MarkdownDescription: "ExternalTracker represents settings for external tracker",
			},
			"external_wiki": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"external_wiki_url": schema.StringAttribute{
						Computed:            true,
						Description:         "URL of external wiki.",
						MarkdownDescription: "URL of external wiki.",
					},
				},
				CustomType: ExternalWikiType{
					ObjectType: types.ObjectType{
						AttrTypes: ExternalWikiValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "ExternalWiki represents setting for external wiki",
				MarkdownDescription: "ExternalWiki represents setting for external wiki",
			},
			"fork": schema.BoolAttribute{
				Computed: true,
			},
			"forks_count": schema.Int64Attribute{
				Computed: true,
			},
			"full_name": schema.StringAttribute{
				Computed: true,
			},
			"has_actions": schema.BoolAttribute{
				Computed: true,
			},
			"has_code": schema.BoolAttribute{
				Computed: true,
			},
			"has_issues": schema.BoolAttribute{
				Computed: true,
			},
			"has_packages": schema.BoolAttribute{
				Computed: true,
			},
			"has_projects": schema.BoolAttribute{
				Computed: true,
			},
			"has_pull_requests": schema.BoolAttribute{
				Computed: true,
			},
			"has_releases": schema.BoolAttribute{
				Computed: true,
			},
			"has_wiki": schema.BoolAttribute{
				Computed: true,
			},
			"html_url": schema.StringAttribute{
				Computed: true,
			},
			"id": schema.Int64Attribute{
				Computed: true,
			},
			"ignore_whitespace_conflicts": schema.BoolAttribute{
				Computed: true,
			},
			"internal": schema.BoolAttribute{
				Computed: true,
			},
			"internal_tracker": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"allow_only_contributors_to_track_time": schema.BoolAttribute{
						Computed:            true,
						Description:         "Let only contributors track time (Built-in issue tracker)",
						MarkdownDescription: "Let only contributors track time (Built-in issue tracker)",
					},
					"enable_issue_dependencies": schema.BoolAttribute{
						Computed:            true,
						Description:         "Enable dependencies for issues and pull requests (Built-in issue tracker)",
						MarkdownDescription: "Enable dependencies for issues and pull requests (Built-in issue tracker)",
					},
					"enable_time_tracker": schema.BoolAttribute{
						Computed:            true,
						Description:         "Enable time tracking (Built-in issue tracker)",
						MarkdownDescription: "Enable time tracking (Built-in issue tracker)",
					},
				},
				CustomType: InternalTrackerType{
					ObjectType: types.ObjectType{
						AttrTypes: InternalTrackerValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "InternalTracker represents settings for internal tracker",
				MarkdownDescription: "InternalTracker represents settings for internal tracker",
			},
			"language": schema.StringAttribute{
				Computed: true,
			},
			"languages_url": schema.StringAttribute{
				Computed: true,
			},
			"licenses": schema.ListAttribute{
				ElementType: types.StringType,
				Computed:    true,
			},
			"link": schema.StringAttribute{
				Computed: true,
			},
			"mirror": schema.BoolAttribute{
				Computed: true,
			},
			"mirror_interval": schema.StringAttribute{
				Computed: true,
			},
			"mirror_updated": schema.StringAttribute{
				Computed: true,
			},
			"name": schema.StringAttribute{
				Computed: true,
			},
			"object_format_name": schema.StringAttribute{
				Computed:            true,
				Description:         "ObjectFormatName of the underlying git repository",
				MarkdownDescription: "ObjectFormatName of the underlying git repository",
			},
			"open_issues_count": schema.Int64Attribute{
				Computed: true,
			},
			"open_pr_counter": schema.Int64Attribute{
				Computed: true,
			},
			"original_url": schema.StringAttribute{
				Computed: true,
			},
			"owner": schema.StringAttribute{
				Required:            true,
				Description:         "owner of the repo",
				MarkdownDescription: "owner of the repo",
			},
			"permissions": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"admin": schema.BoolAttribute{
						Computed: true,
					},
					"pull": schema.BoolAttribute{
						Computed: true,
					},
					"push": schema.BoolAttribute{
						Computed: true,
					},
				},
				CustomType: PermissionsType{
					ObjectType: types.ObjectType{
						AttrTypes: PermissionsValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "Permission represents a set of permissions",
				MarkdownDescription: "Permission represents a set of permissions",
			},
			"private": schema.BoolAttribute{
				Computed: true,
			},
			"projects_mode": schema.StringAttribute{
				Computed: true,
			},
			"release_counter": schema.Int64Attribute{
				Computed: true,
			},
			"repo": schema.StringAttribute{
				Required:            true,
				Description:         "name of the repo",
				MarkdownDescription: "name of the repo",
			},
			"repo_transfer": schema.SingleNestedAttribute{
				Attributes: map[string]schema.Attribute{
					"doer": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"active": schema.BoolAttribute{
								Computed:            true,
								Description:         "Is user active",
								MarkdownDescription: "Is user active",
							},
							"avatar_url": schema.StringAttribute{
								Computed:            true,
								Description:         "URL to the user's avatar",
								MarkdownDescription: "URL to the user's avatar",
							},
							"created": schema.StringAttribute{
								Computed: true,
							},
							"description": schema.StringAttribute{
								Computed:            true,
								Description:         "the user's description",
								MarkdownDescription: "the user's description",
							},
							"email": schema.StringAttribute{
								Computed: true,
							},
							"followers_count": schema.Int64Attribute{
								Computed:            true,
								Description:         "user counts",
								MarkdownDescription: "user counts",
							},
							"following_count": schema.Int64Attribute{
								Computed: true,
							},
							"full_name": schema.StringAttribute{
								Computed:            true,
								Description:         "the user's full name",
								MarkdownDescription: "the user's full name",
							},
							"html_url": schema.StringAttribute{
								Computed:            true,
								Description:         "URL to the user's gitea page",
								MarkdownDescription: "URL to the user's gitea page",
							},
							"id": schema.Int64Attribute{
								Computed:            true,
								Description:         "the user's id",
								MarkdownDescription: "the user's id",
							},
							"is_admin": schema.BoolAttribute{
								Computed:            true,
								Description:         "Is the user an administrator",
								MarkdownDescription: "Is the user an administrator",
							},
							"language": schema.StringAttribute{
								Computed:            true,
								Description:         "User locale",
								MarkdownDescription: "User locale",
							},
							"last_login": schema.StringAttribute{
								Computed: true,
							},
							"location": schema.StringAttribute{
								Computed:            true,
								Description:         "the user's location",
								MarkdownDescription: "the user's location",
							},
							"login": schema.StringAttribute{
								Computed:            true,
								Description:         "login of the user, same as `username`",
								MarkdownDescription: "login of the user, same as `username`",
							},
							"login_name": schema.StringAttribute{
								Computed:            true,
								Description:         "identifier of the user, provided by the external authenticator (if configured)",
								MarkdownDescription: "identifier of the user, provided by the external authenticator (if configured)",
							},
							"prohibit_login": schema.BoolAttribute{
								Computed:            true,
								Description:         "Is user login prohibited",
								MarkdownDescription: "Is user login prohibited",
							},
							"restricted": schema.BoolAttribute{
								Computed:            true,
								Description:         "Is user restricted",
								MarkdownDescription: "Is user restricted",
							},
							"source_id": schema.Int64Attribute{
								Computed:            true,
								Description:         "The ID of the user's Authentication Source",
								MarkdownDescription: "The ID of the user's Authentication Source",
							},
							"starred_repos_count": schema.Int64Attribute{
								Computed: true,
							},
							"visibility": schema.StringAttribute{
								Computed:            true,
								Description:         "User visibility level option: public, limited, private",
								MarkdownDescription: "User visibility level option: public, limited, private",
							},
							"website": schema.StringAttribute{
								Computed:            true,
								Description:         "the user's website",
								MarkdownDescription: "the user's website",
							},
						},
						CustomType: DoerType{
							ObjectType: types.ObjectType{
								AttrTypes: DoerValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "User represents a user",
						MarkdownDescription: "User represents a user",
					},
					"recipient": schema.SingleNestedAttribute{
						Attributes: map[string]schema.Attribute{
							"active": schema.BoolAttribute{
								Computed:            true,
								Description:         "Is user active",
								MarkdownDescription: "Is user active",
							},
							"avatar_url": schema.StringAttribute{
								Computed:            true,
								Description:         "URL to the user's avatar",
								MarkdownDescription: "URL to the user's avatar",
							},
							"created": schema.StringAttribute{
								Computed: true,
							},
							"description": schema.StringAttribute{
								Computed:            true,
								Description:         "the user's description",
								MarkdownDescription: "the user's description",
							},
							"email": schema.StringAttribute{
								Computed: true,
							},
							"followers_count": schema.Int64Attribute{
								Computed:            true,
								Description:         "user counts",
								MarkdownDescription: "user counts",
							},
							"following_count": schema.Int64Attribute{
								Computed: true,
							},
							"full_name": schema.StringAttribute{
								Computed:            true,
								Description:         "the user's full name",
								MarkdownDescription: "the user's full name",
							},
							"html_url": schema.StringAttribute{
								Computed:            true,
								Description:         "URL to the user's gitea page",
								MarkdownDescription: "URL to the user's gitea page",
							},
							"id": schema.Int64Attribute{
								Computed:            true,
								Description:         "the user's id",
								MarkdownDescription: "the user's id",
							},
							"is_admin": schema.BoolAttribute{
								Computed:            true,
								Description:         "Is the user an administrator",
								MarkdownDescription: "Is the user an administrator",
							},
							"language": schema.StringAttribute{
								Computed:            true,
								Description:         "User locale",
								MarkdownDescription: "User locale",
							},
							"last_login": schema.StringAttribute{
								Computed: true,
							},
							"location": schema.StringAttribute{
								Computed:            true,
								Description:         "the user's location",
								MarkdownDescription: "the user's location",
							},
							"login": schema.StringAttribute{
								Computed:            true,
								Description:         "login of the user, same as `username`",
								MarkdownDescription: "login of the user, same as `username`",
							},
							"login_name": schema.StringAttribute{
								Computed:            true,
								Description:         "identifier of the user, provided by the external authenticator (if configured)",
								MarkdownDescription: "identifier of the user, provided by the external authenticator (if configured)",
							},
							"prohibit_login": schema.BoolAttribute{
								Computed:            true,
								Description:         "Is user login prohibited",
								MarkdownDescription: "Is user login prohibited",
							},
							"restricted": schema.BoolAttribute{
								Computed:            true,
								Description:         "Is user restricted",
								MarkdownDescription: "Is user restricted",
							},
							"source_id": schema.Int64Attribute{
								Computed:            true,
								Description:         "The ID of the user's Authentication Source",
								MarkdownDescription: "The ID of the user's Authentication Source",
							},
							"starred_repos_count": schema.Int64Attribute{
								Computed: true,
							},
							"visibility": schema.StringAttribute{
								Computed:            true,
								Description:         "User visibility level option: public, limited, private",
								MarkdownDescription: "User visibility level option: public, limited, private",
							},
							"website": schema.StringAttribute{
								Computed:            true,
								Description:         "the user's website",
								MarkdownDescription: "the user's website",
							},
						},
						CustomType: RecipientType{
							ObjectType: types.ObjectType{
								AttrTypes: RecipientValue{}.AttributeTypes(ctx),
							},
						},
						Computed:            true,
						Description:         "User represents a user",
						MarkdownDescription: "User represents a user",
					},
					"teams": schema.ListNestedAttribute{
						NestedObject: schema.NestedAttributeObject{
							Attributes: map[string]schema.Attribute{
								"can_create_org_repo": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether the team can create repositories in the organization",
									MarkdownDescription: "Whether the team can create repositories in the organization",
								},
								"description": schema.StringAttribute{
									Computed:            true,
									Description:         "The description of the team",
									MarkdownDescription: "The description of the team",
								},
								"id": schema.Int64Attribute{
									Computed:            true,
									Description:         "The unique identifier of the team",
									MarkdownDescription: "The unique identifier of the team",
								},
								"includes_all_repositories": schema.BoolAttribute{
									Computed:            true,
									Description:         "Whether the team has access to all repositories in the organization",
									MarkdownDescription: "Whether the team has access to all repositories in the organization",
								},
								"name": schema.StringAttribute{
									Computed:            true,
									Description:         "The name of the team",
									MarkdownDescription: "The name of the team",
								},
								"organization": schema.SingleNestedAttribute{
									Attributes: map[string]schema.Attribute{
										"avatar_url": schema.StringAttribute{
											Computed:            true,
											Description:         "The URL of the organization's avatar",
											MarkdownDescription: "The URL of the organization's avatar",
										},
										"description": schema.StringAttribute{
											Computed:            true,
											Description:         "The description of the organization",
											MarkdownDescription: "The description of the organization",
										},
										"email": schema.StringAttribute{
											Computed:            true,
											Description:         "The email address of the organization",
											MarkdownDescription: "The email address of the organization",
										},
										"full_name": schema.StringAttribute{
											Computed:            true,
											Description:         "The full display name of the organization",
											MarkdownDescription: "The full display name of the organization",
										},
										"id": schema.Int64Attribute{
											Computed:            true,
											Description:         "The unique identifier of the organization",
											MarkdownDescription: "The unique identifier of the organization",
										},
										"location": schema.StringAttribute{
											Computed:            true,
											Description:         "The location of the organization",
											MarkdownDescription: "The location of the organization",
										},
										"name": schema.StringAttribute{
											Computed:            true,
											Description:         "The name of the organization",
											MarkdownDescription: "The name of the organization",
										},
										"repo_admin_change_team_access": schema.BoolAttribute{
											Computed:            true,
											Description:         "Whether repository administrators can change team access",
											MarkdownDescription: "Whether repository administrators can change team access",
										},
										"username": schema.StringAttribute{
											Computed:            true,
											Description:         "username of the organization\ndeprecated",
											MarkdownDescription: "username of the organization\ndeprecated",
										},
										"visibility": schema.StringAttribute{
											Computed:            true,
											Description:         "The visibility level of the organization (public, limited, private)",
											MarkdownDescription: "The visibility level of the organization (public, limited, private)",
										},
										"website": schema.StringAttribute{
											Computed:            true,
											Description:         "The website URL of the organization",
											MarkdownDescription: "The website URL of the organization",
										},
									},
									CustomType: OrganizationType{
										ObjectType: types.ObjectType{
											AttrTypes: OrganizationValue{}.AttributeTypes(ctx),
										},
									},
									Computed:            true,
									Description:         "Organization represents an organization",
									MarkdownDescription: "Organization represents an organization",
								},
								"permission": schema.StringAttribute{
									Computed: true,
								},
								"units": schema.ListAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
								"units_map": schema.MapAttribute{
									ElementType: types.StringType,
									Computed:    true,
								},
							},
							CustomType: TeamsType{
								ObjectType: types.ObjectType{
									AttrTypes: TeamsValue{}.AttributeTypes(ctx),
								},
							},
						},
						Computed: true,
					},
				},
				CustomType: RepoTransferType{
					ObjectType: types.ObjectType{
						AttrTypes: RepoTransferValue{}.AttributeTypes(ctx),
					},
				},
				Computed:            true,
				Description:         "RepoTransfer represents a pending repo transfer",
				MarkdownDescription: "RepoTransfer represents a pending repo transfer",
			},
			"size": schema.Int64Attribute{
				Computed: true,
			},
			"ssh_url": schema.StringAttribute{
				Computed: true,
			},
			"stars_count": schema.Int64Attribute{
				Computed: true,
			},
			"template": schema.BoolAttribute{
				Computed: true,
			},
			"topics": schema.ListAttribute{
				ElementType: types.StringType,
				Computed:    true,
			},
			"updated_at": schema.StringAttribute{
				Computed: true,
			},
			"url": schema.StringAttribute{
				Computed: true,
			},
			"watchers_count": schema.Int64Attribute{
				Computed: true,
			},
			"website": schema.StringAttribute{
				Computed: true,
			},
		},
	}
}

type RepositoryModel struct {
	AllowFastForwardOnlyMerge     types.Bool           `tfsdk:"allow_fast_forward_only_merge"`
	AllowManualMerge              types.Bool           `tfsdk:"allow_manual_merge"`
	AllowMergeCommits             types.Bool           `tfsdk:"allow_merge_commits"`
	AllowRebase                   types.Bool           `tfsdk:"allow_rebase"`
	AllowRebaseExplicit           types.Bool           `tfsdk:"allow_rebase_explicit"`
	AllowRebaseUpdate             types.Bool           `tfsdk:"allow_rebase_update"`
	AllowSquashMerge              types.Bool           `tfsdk:"allow_squash_merge"`
	Archived                      types.Bool           `tfsdk:"archived"`
	ArchivedAt                    types.String         `tfsdk:"archived_at"`
	AutodetectManualMerge         types.Bool           `tfsdk:"autodetect_manual_merge"`
	AvatarUrl                     types.String         `tfsdk:"avatar_url"`
	CloneUrl                      types.String         `tfsdk:"clone_url"`
	CreatedAt                     types.String         `tfsdk:"created_at"`
	DefaultAllowMaintainerEdit    types.Bool           `tfsdk:"default_allow_maintainer_edit"`
	DefaultBranch                 types.String         `tfsdk:"default_branch"`
	DefaultDeleteBranchAfterMerge types.Bool           `tfsdk:"default_delete_branch_after_merge"`
	DefaultMergeStyle             types.String         `tfsdk:"default_merge_style"`
	Description                   types.String         `tfsdk:"description"`
	Empty                         types.Bool           `tfsdk:"empty"`
	ExternalTracker               ExternalTrackerValue `tfsdk:"external_tracker"`
	ExternalWiki                  ExternalWikiValue    `tfsdk:"external_wiki"`
	Fork                          types.Bool           `tfsdk:"fork"`
	ForksCount                    types.Int64          `tfsdk:"forks_count"`
	FullName                      types.String         `tfsdk:"full_name"`
	HasActions                    types.Bool           `tfsdk:"has_actions"`
	HasCode                       types.Bool           `tfsdk:"has_code"`
	HasIssues                     types.Bool           `tfsdk:"has_issues"`
	HasPackages                   types.Bool           `tfsdk:"has_packages"`
	HasProjects                   types.Bool           `tfsdk:"has_projects"`
	HasPullRequests               types.Bool           `tfsdk:"has_pull_requests"`
	HasReleases                   types.Bool           `tfsdk:"has_releases"`
	HasWiki                       types.Bool           `tfsdk:"has_wiki"`
	HtmlUrl                       types.String         `tfsdk:"html_url"`
	Id                            types.Int64          `tfsdk:"id"`
	IgnoreWhitespaceConflicts     types.Bool           `tfsdk:"ignore_whitespace_conflicts"`
	Internal                      types.Bool           `tfsdk:"internal"`
	InternalTracker               InternalTrackerValue `tfsdk:"internal_tracker"`
	Language                      types.String         `tfsdk:"language"`
	LanguagesUrl                  types.String         `tfsdk:"languages_url"`
	Licenses                      types.List           `tfsdk:"licenses"`
	Link                          types.String         `tfsdk:"link"`
	Mirror                        types.Bool           `tfsdk:"mirror"`
	MirrorInterval                types.String         `tfsdk:"mirror_interval"`
	MirrorUpdated                 types.String         `tfsdk:"mirror_updated"`
	Name                          types.String         `tfsdk:"name"`
	ObjectFormatName              types.String         `tfsdk:"object_format_name"`
	OpenIssuesCount               types.Int64          `tfsdk:"open_issues_count"`
	OpenPrCounter                 types.Int64          `tfsdk:"open_pr_counter"`
	OriginalUrl                   types.String         `tfsdk:"original_url"`
	Owner                         types.String         `tfsdk:"owner"`
	Permissions                   PermissionsValue     `tfsdk:"permissions"`
	Private                       types.Bool           `tfsdk:"private"`
	ProjectsMode                  types.String         `tfsdk:"projects_mode"`
	ReleaseCounter                types.Int64          `tfsdk:"release_counter"`
	Repo                          types.String         `tfsdk:"repo"`
	RepoTransfer                  RepoTransferValue    `tfsdk:"repo_transfer"`
	Size                          types.Int64          `tfsdk:"size"`
	SshUrl                        types.String         `tfsdk:"ssh_url"`
	StarsCount                    types.Int64          `tfsdk:"stars_count"`
	Template                      types.Bool           `tfsdk:"template"`
	Topics                        types.List           `tfsdk:"topics"`
	UpdatedAt                     types.String         `tfsdk:"updated_at"`
	Url                           types.String         `tfsdk:"url"`
	WatchersCount                 types.Int64          `tfsdk:"watchers_count"`
	Website                       types.String         `tfsdk:"website"`
}

var _ basetypes.ObjectTypable = ExternalTrackerType{}

type ExternalTrackerType struct {
	basetypes.ObjectType
}

func (t ExternalTrackerType) Equal(o attr.Type) bool {
	other, ok := o.(ExternalTrackerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExternalTrackerType) String() string {
	return "ExternalTrackerType"
}

func (t ExternalTrackerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	externalTrackerFormatAttribute, ok := attributes["external_tracker_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_tracker_format is missing from object`)

		return nil, diags
	}

	externalTrackerFormatVal, ok := externalTrackerFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_tracker_format expected to be basetypes.StringValue, was: %T`, externalTrackerFormatAttribute))
	}

	externalTrackerRegexpPatternAttribute, ok := attributes["external_tracker_regexp_pattern"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_tracker_regexp_pattern is missing from object`)

		return nil, diags
	}

	externalTrackerRegexpPatternVal, ok := externalTrackerRegexpPatternAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_tracker_regexp_pattern expected to be basetypes.StringValue, was: %T`, externalTrackerRegexpPatternAttribute))
	}

	externalTrackerStyleAttribute, ok := attributes["external_tracker_style"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_tracker_style is missing from object`)

		return nil, diags
	}

	externalTrackerStyleVal, ok := externalTrackerStyleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_tracker_style expected to be basetypes.StringValue, was: %T`, externalTrackerStyleAttribute))
	}

	externalTrackerUrlAttribute, ok := attributes["external_tracker_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_tracker_url is missing from object`)

		return nil, diags
	}

	externalTrackerUrlVal, ok := externalTrackerUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_tracker_url expected to be basetypes.StringValue, was: %T`, externalTrackerUrlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExternalTrackerValue{
		ExternalTrackerFormat:        externalTrackerFormatVal,
		ExternalTrackerRegexpPattern: externalTrackerRegexpPatternVal,
		ExternalTrackerStyle:         externalTrackerStyleVal,
		ExternalTrackerUrl:           externalTrackerUrlVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewExternalTrackerValueNull() ExternalTrackerValue {
	return ExternalTrackerValue{
		state: attr.ValueStateNull,
	}
}

func NewExternalTrackerValueUnknown() ExternalTrackerValue {
	return ExternalTrackerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExternalTrackerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExternalTrackerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExternalTrackerValue Attribute Value",
				"While creating a ExternalTrackerValue value, a missing attribute value was detected. "+
					"A ExternalTrackerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExternalTrackerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExternalTrackerValue Attribute Type",
				"While creating a ExternalTrackerValue value, an invalid attribute value was detected. "+
					"A ExternalTrackerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExternalTrackerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExternalTrackerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExternalTrackerValue Attribute Value",
				"While creating a ExternalTrackerValue value, an extra attribute value was detected. "+
					"A ExternalTrackerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExternalTrackerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExternalTrackerValueUnknown(), diags
	}

	externalTrackerFormatAttribute, ok := attributes["external_tracker_format"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_tracker_format is missing from object`)

		return NewExternalTrackerValueUnknown(), diags
	}

	externalTrackerFormatVal, ok := externalTrackerFormatAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_tracker_format expected to be basetypes.StringValue, was: %T`, externalTrackerFormatAttribute))
	}

	externalTrackerRegexpPatternAttribute, ok := attributes["external_tracker_regexp_pattern"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_tracker_regexp_pattern is missing from object`)

		return NewExternalTrackerValueUnknown(), diags
	}

	externalTrackerRegexpPatternVal, ok := externalTrackerRegexpPatternAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_tracker_regexp_pattern expected to be basetypes.StringValue, was: %T`, externalTrackerRegexpPatternAttribute))
	}

	externalTrackerStyleAttribute, ok := attributes["external_tracker_style"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_tracker_style is missing from object`)

		return NewExternalTrackerValueUnknown(), diags
	}

	externalTrackerStyleVal, ok := externalTrackerStyleAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_tracker_style expected to be basetypes.StringValue, was: %T`, externalTrackerStyleAttribute))
	}

	externalTrackerUrlAttribute, ok := attributes["external_tracker_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_tracker_url is missing from object`)

		return NewExternalTrackerValueUnknown(), diags
	}

	externalTrackerUrlVal, ok := externalTrackerUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_tracker_url expected to be basetypes.StringValue, was: %T`, externalTrackerUrlAttribute))
	}

	if diags.HasError() {
		return NewExternalTrackerValueUnknown(), diags
	}

	return ExternalTrackerValue{
		ExternalTrackerFormat:        externalTrackerFormatVal,
		ExternalTrackerRegexpPattern: externalTrackerRegexpPatternVal,
		ExternalTrackerStyle:         externalTrackerStyleVal,
		ExternalTrackerUrl:           externalTrackerUrlVal,
		state:                        attr.ValueStateKnown,
	}, diags
}

func NewExternalTrackerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExternalTrackerValue {
	object, diags := NewExternalTrackerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExternalTrackerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExternalTrackerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExternalTrackerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExternalTrackerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExternalTrackerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExternalTrackerValueMust(ExternalTrackerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExternalTrackerType) ValueType(ctx context.Context) attr.Value {
	return ExternalTrackerValue{}
}

var _ basetypes.ObjectValuable = ExternalTrackerValue{}

type ExternalTrackerValue struct {
	ExternalTrackerFormat        basetypes.StringValue `tfsdk:"external_tracker_format"`
	ExternalTrackerRegexpPattern basetypes.StringValue `tfsdk:"external_tracker_regexp_pattern"`
	ExternalTrackerStyle         basetypes.StringValue `tfsdk:"external_tracker_style"`
	ExternalTrackerUrl           basetypes.StringValue `tfsdk:"external_tracker_url"`
	state                        attr.ValueState
}

func (v ExternalTrackerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 4)

	var val tftypes.Value
	var err error

	attrTypes["external_tracker_format"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_tracker_regexp_pattern"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_tracker_style"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["external_tracker_url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 4)

		val, err = v.ExternalTrackerFormat.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_tracker_format"] = val

		val, err = v.ExternalTrackerRegexpPattern.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_tracker_regexp_pattern"] = val

		val, err = v.ExternalTrackerStyle.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_tracker_style"] = val

		val, err = v.ExternalTrackerUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_tracker_url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExternalTrackerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExternalTrackerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExternalTrackerValue) String() string {
	return "ExternalTrackerValue"
}

func (v ExternalTrackerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"external_tracker_format":         basetypes.StringType{},
		"external_tracker_regexp_pattern": basetypes.StringType{},
		"external_tracker_style":          basetypes.StringType{},
		"external_tracker_url":            basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"external_tracker_format":         v.ExternalTrackerFormat,
			"external_tracker_regexp_pattern": v.ExternalTrackerRegexpPattern,
			"external_tracker_style":          v.ExternalTrackerStyle,
			"external_tracker_url":            v.ExternalTrackerUrl,
		})

	return objVal, diags
}

func (v ExternalTrackerValue) Equal(o attr.Value) bool {
	other, ok := o.(ExternalTrackerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExternalTrackerFormat.Equal(other.ExternalTrackerFormat) {
		return false
	}

	if !v.ExternalTrackerRegexpPattern.Equal(other.ExternalTrackerRegexpPattern) {
		return false
	}

	if !v.ExternalTrackerStyle.Equal(other.ExternalTrackerStyle) {
		return false
	}

	if !v.ExternalTrackerUrl.Equal(other.ExternalTrackerUrl) {
		return false
	}

	return true
}

func (v ExternalTrackerValue) Type(ctx context.Context) attr.Type {
	return ExternalTrackerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExternalTrackerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"external_tracker_format":         basetypes.StringType{},
		"external_tracker_regexp_pattern": basetypes.StringType{},
		"external_tracker_style":          basetypes.StringType{},
		"external_tracker_url":            basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = ExternalWikiType{}

type ExternalWikiType struct {
	basetypes.ObjectType
}

func (t ExternalWikiType) Equal(o attr.Type) bool {
	other, ok := o.(ExternalWikiType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t ExternalWikiType) String() string {
	return "ExternalWikiType"
}

func (t ExternalWikiType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	externalWikiUrlAttribute, ok := attributes["external_wiki_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_wiki_url is missing from object`)

		return nil, diags
	}

	externalWikiUrlVal, ok := externalWikiUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_wiki_url expected to be basetypes.StringValue, was: %T`, externalWikiUrlAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return ExternalWikiValue{
		ExternalWikiUrl: externalWikiUrlVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewExternalWikiValueNull() ExternalWikiValue {
	return ExternalWikiValue{
		state: attr.ValueStateNull,
	}
}

func NewExternalWikiValueUnknown() ExternalWikiValue {
	return ExternalWikiValue{
		state: attr.ValueStateUnknown,
	}
}

func NewExternalWikiValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (ExternalWikiValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing ExternalWikiValue Attribute Value",
				"While creating a ExternalWikiValue value, a missing attribute value was detected. "+
					"A ExternalWikiValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExternalWikiValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid ExternalWikiValue Attribute Type",
				"While creating a ExternalWikiValue value, an invalid attribute value was detected. "+
					"A ExternalWikiValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("ExternalWikiValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("ExternalWikiValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra ExternalWikiValue Attribute Value",
				"While creating a ExternalWikiValue value, an extra attribute value was detected. "+
					"A ExternalWikiValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra ExternalWikiValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewExternalWikiValueUnknown(), diags
	}

	externalWikiUrlAttribute, ok := attributes["external_wiki_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`external_wiki_url is missing from object`)

		return NewExternalWikiValueUnknown(), diags
	}

	externalWikiUrlVal, ok := externalWikiUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`external_wiki_url expected to be basetypes.StringValue, was: %T`, externalWikiUrlAttribute))
	}

	if diags.HasError() {
		return NewExternalWikiValueUnknown(), diags
	}

	return ExternalWikiValue{
		ExternalWikiUrl: externalWikiUrlVal,
		state:           attr.ValueStateKnown,
	}, diags
}

func NewExternalWikiValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) ExternalWikiValue {
	object, diags := NewExternalWikiValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewExternalWikiValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t ExternalWikiType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewExternalWikiValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewExternalWikiValueUnknown(), nil
	}

	if in.IsNull() {
		return NewExternalWikiValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewExternalWikiValueMust(ExternalWikiValue{}.AttributeTypes(ctx), attributes), nil
}

func (t ExternalWikiType) ValueType(ctx context.Context) attr.Value {
	return ExternalWikiValue{}
}

var _ basetypes.ObjectValuable = ExternalWikiValue{}

type ExternalWikiValue struct {
	ExternalWikiUrl basetypes.StringValue `tfsdk:"external_wiki_url"`
	state           attr.ValueState
}

func (v ExternalWikiValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 1)

	var val tftypes.Value
	var err error

	attrTypes["external_wiki_url"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 1)

		val, err = v.ExternalWikiUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["external_wiki_url"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v ExternalWikiValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v ExternalWikiValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v ExternalWikiValue) String() string {
	return "ExternalWikiValue"
}

func (v ExternalWikiValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"external_wiki_url": basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"external_wiki_url": v.ExternalWikiUrl,
		})

	return objVal, diags
}

func (v ExternalWikiValue) Equal(o attr.Value) bool {
	other, ok := o.(ExternalWikiValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.ExternalWikiUrl.Equal(other.ExternalWikiUrl) {
		return false
	}

	return true
}

func (v ExternalWikiValue) Type(ctx context.Context) attr.Type {
	return ExternalWikiType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v ExternalWikiValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"external_wiki_url": basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = InternalTrackerType{}

type InternalTrackerType struct {
	basetypes.ObjectType
}

func (t InternalTrackerType) Equal(o attr.Type) bool {
	other, ok := o.(InternalTrackerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t InternalTrackerType) String() string {
	return "InternalTrackerType"
}

func (t InternalTrackerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	allowOnlyContributorsToTrackTimeAttribute, ok := attributes["allow_only_contributors_to_track_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_only_contributors_to_track_time is missing from object`)

		return nil, diags
	}

	allowOnlyContributorsToTrackTimeVal, ok := allowOnlyContributorsToTrackTimeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_only_contributors_to_track_time expected to be basetypes.BoolValue, was: %T`, allowOnlyContributorsToTrackTimeAttribute))
	}

	enableIssueDependenciesAttribute, ok := attributes["enable_issue_dependencies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_issue_dependencies is missing from object`)

		return nil, diags
	}

	enableIssueDependenciesVal, ok := enableIssueDependenciesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_issue_dependencies expected to be basetypes.BoolValue, was: %T`, enableIssueDependenciesAttribute))
	}

	enableTimeTrackerAttribute, ok := attributes["enable_time_tracker"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_time_tracker is missing from object`)

		return nil, diags
	}

	enableTimeTrackerVal, ok := enableTimeTrackerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_time_tracker expected to be basetypes.BoolValue, was: %T`, enableTimeTrackerAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return InternalTrackerValue{
		AllowOnlyContributorsToTrackTime: allowOnlyContributorsToTrackTimeVal,
		EnableIssueDependencies:          enableIssueDependenciesVal,
		EnableTimeTracker:                enableTimeTrackerVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewInternalTrackerValueNull() InternalTrackerValue {
	return InternalTrackerValue{
		state: attr.ValueStateNull,
	}
}

func NewInternalTrackerValueUnknown() InternalTrackerValue {
	return InternalTrackerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewInternalTrackerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (InternalTrackerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing InternalTrackerValue Attribute Value",
				"While creating a InternalTrackerValue value, a missing attribute value was detected. "+
					"A InternalTrackerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternalTrackerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid InternalTrackerValue Attribute Type",
				"While creating a InternalTrackerValue value, an invalid attribute value was detected. "+
					"A InternalTrackerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("InternalTrackerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("InternalTrackerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra InternalTrackerValue Attribute Value",
				"While creating a InternalTrackerValue value, an extra attribute value was detected. "+
					"A InternalTrackerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra InternalTrackerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewInternalTrackerValueUnknown(), diags
	}

	allowOnlyContributorsToTrackTimeAttribute, ok := attributes["allow_only_contributors_to_track_time"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`allow_only_contributors_to_track_time is missing from object`)

		return NewInternalTrackerValueUnknown(), diags
	}

	allowOnlyContributorsToTrackTimeVal, ok := allowOnlyContributorsToTrackTimeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`allow_only_contributors_to_track_time expected to be basetypes.BoolValue, was: %T`, allowOnlyContributorsToTrackTimeAttribute))
	}

	enableIssueDependenciesAttribute, ok := attributes["enable_issue_dependencies"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_issue_dependencies is missing from object`)

		return NewInternalTrackerValueUnknown(), diags
	}

	enableIssueDependenciesVal, ok := enableIssueDependenciesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_issue_dependencies expected to be basetypes.BoolValue, was: %T`, enableIssueDependenciesAttribute))
	}

	enableTimeTrackerAttribute, ok := attributes["enable_time_tracker"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`enable_time_tracker is missing from object`)

		return NewInternalTrackerValueUnknown(), diags
	}

	enableTimeTrackerVal, ok := enableTimeTrackerAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`enable_time_tracker expected to be basetypes.BoolValue, was: %T`, enableTimeTrackerAttribute))
	}

	if diags.HasError() {
		return NewInternalTrackerValueUnknown(), diags
	}

	return InternalTrackerValue{
		AllowOnlyContributorsToTrackTime: allowOnlyContributorsToTrackTimeVal,
		EnableIssueDependencies:          enableIssueDependenciesVal,
		EnableTimeTracker:                enableTimeTrackerVal,
		state:                            attr.ValueStateKnown,
	}, diags
}

func NewInternalTrackerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) InternalTrackerValue {
	object, diags := NewInternalTrackerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewInternalTrackerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t InternalTrackerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewInternalTrackerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewInternalTrackerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewInternalTrackerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewInternalTrackerValueMust(InternalTrackerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t InternalTrackerType) ValueType(ctx context.Context) attr.Value {
	return InternalTrackerValue{}
}

var _ basetypes.ObjectValuable = InternalTrackerValue{}

type InternalTrackerValue struct {
	AllowOnlyContributorsToTrackTime basetypes.BoolValue `tfsdk:"allow_only_contributors_to_track_time"`
	EnableIssueDependencies          basetypes.BoolValue `tfsdk:"enable_issue_dependencies"`
	EnableTimeTracker                basetypes.BoolValue `tfsdk:"enable_time_tracker"`
	state                            attr.ValueState
}

func (v InternalTrackerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["allow_only_contributors_to_track_time"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_issue_dependencies"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["enable_time_tracker"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.AllowOnlyContributorsToTrackTime.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["allow_only_contributors_to_track_time"] = val

		val, err = v.EnableIssueDependencies.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_issue_dependencies"] = val

		val, err = v.EnableTimeTracker.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["enable_time_tracker"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v InternalTrackerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v InternalTrackerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v InternalTrackerValue) String() string {
	return "InternalTrackerValue"
}

func (v InternalTrackerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"allow_only_contributors_to_track_time": basetypes.BoolType{},
		"enable_issue_dependencies":             basetypes.BoolType{},
		"enable_time_tracker":                   basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"allow_only_contributors_to_track_time": v.AllowOnlyContributorsToTrackTime,
			"enable_issue_dependencies":             v.EnableIssueDependencies,
			"enable_time_tracker":                   v.EnableTimeTracker,
		})

	return objVal, diags
}

func (v InternalTrackerValue) Equal(o attr.Value) bool {
	other, ok := o.(InternalTrackerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AllowOnlyContributorsToTrackTime.Equal(other.AllowOnlyContributorsToTrackTime) {
		return false
	}

	if !v.EnableIssueDependencies.Equal(other.EnableIssueDependencies) {
		return false
	}

	if !v.EnableTimeTracker.Equal(other.EnableTimeTracker) {
		return false
	}

	return true
}

func (v InternalTrackerValue) Type(ctx context.Context) attr.Type {
	return InternalTrackerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v InternalTrackerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"allow_only_contributors_to_track_time": basetypes.BoolType{},
		"enable_issue_dependencies":             basetypes.BoolType{},
		"enable_time_tracker":                   basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = PermissionsType{}

type PermissionsType struct {
	basetypes.ObjectType
}

func (t PermissionsType) Equal(o attr.Type) bool {
	other, ok := o.(PermissionsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t PermissionsType) String() string {
	return "PermissionsType"
}

func (t PermissionsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	adminAttribute, ok := attributes["admin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`admin is missing from object`)

		return nil, diags
	}

	adminVal, ok := adminAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`admin expected to be basetypes.BoolValue, was: %T`, adminAttribute))
	}

	pullAttribute, ok := attributes["pull"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pull is missing from object`)

		return nil, diags
	}

	pullVal, ok := pullAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pull expected to be basetypes.BoolValue, was: %T`, pullAttribute))
	}

	pushAttribute, ok := attributes["push"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`push is missing from object`)

		return nil, diags
	}

	pushVal, ok := pushAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`push expected to be basetypes.BoolValue, was: %T`, pushAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return PermissionsValue{
		Admin: adminVal,
		Pull:  pullVal,
		Push:  pushVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPermissionsValueNull() PermissionsValue {
	return PermissionsValue{
		state: attr.ValueStateNull,
	}
}

func NewPermissionsValueUnknown() PermissionsValue {
	return PermissionsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewPermissionsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (PermissionsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing PermissionsValue Attribute Value",
				"While creating a PermissionsValue value, a missing attribute value was detected. "+
					"A PermissionsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PermissionsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid PermissionsValue Attribute Type",
				"While creating a PermissionsValue value, an invalid attribute value was detected. "+
					"A PermissionsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("PermissionsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("PermissionsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra PermissionsValue Attribute Value",
				"While creating a PermissionsValue value, an extra attribute value was detected. "+
					"A PermissionsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra PermissionsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewPermissionsValueUnknown(), diags
	}

	adminAttribute, ok := attributes["admin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`admin is missing from object`)

		return NewPermissionsValueUnknown(), diags
	}

	adminVal, ok := adminAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`admin expected to be basetypes.BoolValue, was: %T`, adminAttribute))
	}

	pullAttribute, ok := attributes["pull"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`pull is missing from object`)

		return NewPermissionsValueUnknown(), diags
	}

	pullVal, ok := pullAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`pull expected to be basetypes.BoolValue, was: %T`, pullAttribute))
	}

	pushAttribute, ok := attributes["push"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`push is missing from object`)

		return NewPermissionsValueUnknown(), diags
	}

	pushVal, ok := pushAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`push expected to be basetypes.BoolValue, was: %T`, pushAttribute))
	}

	if diags.HasError() {
		return NewPermissionsValueUnknown(), diags
	}

	return PermissionsValue{
		Admin: adminVal,
		Pull:  pullVal,
		Push:  pushVal,
		state: attr.ValueStateKnown,
	}, diags
}

func NewPermissionsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) PermissionsValue {
	object, diags := NewPermissionsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewPermissionsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t PermissionsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewPermissionsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewPermissionsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewPermissionsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewPermissionsValueMust(PermissionsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t PermissionsType) ValueType(ctx context.Context) attr.Value {
	return PermissionsValue{}
}

var _ basetypes.ObjectValuable = PermissionsValue{}

type PermissionsValue struct {
	Admin basetypes.BoolValue `tfsdk:"admin"`
	Pull  basetypes.BoolValue `tfsdk:"pull"`
	Push  basetypes.BoolValue `tfsdk:"push"`
	state attr.ValueState
}

func (v PermissionsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["admin"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["pull"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["push"] = basetypes.BoolType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Admin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["admin"] = val

		val, err = v.Pull.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["pull"] = val

		val, err = v.Push.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["push"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v PermissionsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v PermissionsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v PermissionsValue) String() string {
	return "PermissionsValue"
}

func (v PermissionsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"admin": basetypes.BoolType{},
		"pull":  basetypes.BoolType{},
		"push":  basetypes.BoolType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"admin": v.Admin,
			"pull":  v.Pull,
			"push":  v.Push,
		})

	return objVal, diags
}

func (v PermissionsValue) Equal(o attr.Value) bool {
	other, ok := o.(PermissionsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Admin.Equal(other.Admin) {
		return false
	}

	if !v.Pull.Equal(other.Pull) {
		return false
	}

	if !v.Push.Equal(other.Push) {
		return false
	}

	return true
}

func (v PermissionsValue) Type(ctx context.Context) attr.Type {
	return PermissionsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v PermissionsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"admin": basetypes.BoolType{},
		"pull":  basetypes.BoolType{},
		"push":  basetypes.BoolType{},
	}
}

var _ basetypes.ObjectTypable = RepoTransferType{}

type RepoTransferType struct {
	basetypes.ObjectType
}

func (t RepoTransferType) Equal(o attr.Type) bool {
	other, ok := o.(RepoTransferType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RepoTransferType) String() string {
	return "RepoTransferType"
}

func (t RepoTransferType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	doerAttribute, ok := attributes["doer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`doer is missing from object`)

		return nil, diags
	}

	doerVal, ok := doerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`doer expected to be basetypes.ObjectValue, was: %T`, doerAttribute))
	}

	recipientAttribute, ok := attributes["recipient"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recipient is missing from object`)

		return nil, diags
	}

	recipientVal, ok := recipientAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recipient expected to be basetypes.ObjectValue, was: %T`, recipientAttribute))
	}

	teamsAttribute, ok := attributes["teams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`teams is missing from object`)

		return nil, diags
	}

	teamsVal, ok := teamsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`teams expected to be basetypes.ListValue, was: %T`, teamsAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RepoTransferValue{
		Doer:      doerVal,
		Recipient: recipientVal,
		Teams:     teamsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewRepoTransferValueNull() RepoTransferValue {
	return RepoTransferValue{
		state: attr.ValueStateNull,
	}
}

func NewRepoTransferValueUnknown() RepoTransferValue {
	return RepoTransferValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRepoTransferValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RepoTransferValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RepoTransferValue Attribute Value",
				"While creating a RepoTransferValue value, a missing attribute value was detected. "+
					"A RepoTransferValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RepoTransferValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RepoTransferValue Attribute Type",
				"While creating a RepoTransferValue value, an invalid attribute value was detected. "+
					"A RepoTransferValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RepoTransferValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RepoTransferValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RepoTransferValue Attribute Value",
				"While creating a RepoTransferValue value, an extra attribute value was detected. "+
					"A RepoTransferValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RepoTransferValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRepoTransferValueUnknown(), diags
	}

	doerAttribute, ok := attributes["doer"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`doer is missing from object`)

		return NewRepoTransferValueUnknown(), diags
	}

	doerVal, ok := doerAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`doer expected to be basetypes.ObjectValue, was: %T`, doerAttribute))
	}

	recipientAttribute, ok := attributes["recipient"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`recipient is missing from object`)

		return NewRepoTransferValueUnknown(), diags
	}

	recipientVal, ok := recipientAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`recipient expected to be basetypes.ObjectValue, was: %T`, recipientAttribute))
	}

	teamsAttribute, ok := attributes["teams"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`teams is missing from object`)

		return NewRepoTransferValueUnknown(), diags
	}

	teamsVal, ok := teamsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`teams expected to be basetypes.ListValue, was: %T`, teamsAttribute))
	}

	if diags.HasError() {
		return NewRepoTransferValueUnknown(), diags
	}

	return RepoTransferValue{
		Doer:      doerVal,
		Recipient: recipientVal,
		Teams:     teamsVal,
		state:     attr.ValueStateKnown,
	}, diags
}

func NewRepoTransferValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RepoTransferValue {
	object, diags := NewRepoTransferValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRepoTransferValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RepoTransferType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRepoTransferValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRepoTransferValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRepoTransferValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRepoTransferValueMust(RepoTransferValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RepoTransferType) ValueType(ctx context.Context) attr.Value {
	return RepoTransferValue{}
}

var _ basetypes.ObjectValuable = RepoTransferValue{}

type RepoTransferValue struct {
	Doer      basetypes.ObjectValue `tfsdk:"doer"`
	Recipient basetypes.ObjectValue `tfsdk:"recipient"`
	Teams     basetypes.ListValue   `tfsdk:"teams"`
	state     attr.ValueState
}

func (v RepoTransferValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 3)

	var val tftypes.Value
	var err error

	attrTypes["doer"] = basetypes.ObjectType{
		AttrTypes: DoerValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["recipient"] = basetypes.ObjectType{
		AttrTypes: RecipientValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["teams"] = basetypes.ListType{
		ElemType: TeamsValue{}.Type(ctx),
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 3)

		val, err = v.Doer.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["doer"] = val

		val, err = v.Recipient.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["recipient"] = val

		val, err = v.Teams.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["teams"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RepoTransferValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RepoTransferValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RepoTransferValue) String() string {
	return "RepoTransferValue"
}

func (v RepoTransferValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var doer basetypes.ObjectValue

	if v.Doer.IsNull() {
		doer = types.ObjectNull(
			DoerValue{}.AttributeTypes(ctx),
		)
	}

	if v.Doer.IsUnknown() {
		doer = types.ObjectUnknown(
			DoerValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Doer.IsNull() && !v.Doer.IsUnknown() {
		doer = types.ObjectValueMust(
			DoerValue{}.AttributeTypes(ctx),
			v.Doer.Attributes(),
		)
	}

	var recipient basetypes.ObjectValue

	if v.Recipient.IsNull() {
		recipient = types.ObjectNull(
			RecipientValue{}.AttributeTypes(ctx),
		)
	}

	if v.Recipient.IsUnknown() {
		recipient = types.ObjectUnknown(
			RecipientValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Recipient.IsNull() && !v.Recipient.IsUnknown() {
		recipient = types.ObjectValueMust(
			RecipientValue{}.AttributeTypes(ctx),
			v.Recipient.Attributes(),
		)
	}

	teams := types.ListValueMust(
		TeamsType{
			basetypes.ObjectType{
				AttrTypes: TeamsValue{}.AttributeTypes(ctx),
			},
		},
		v.Teams.Elements(),
	)

	if v.Teams.IsNull() {
		teams = types.ListNull(
			TeamsType{
				basetypes.ObjectType{
					AttrTypes: TeamsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	if v.Teams.IsUnknown() {
		teams = types.ListUnknown(
			TeamsType{
				basetypes.ObjectType{
					AttrTypes: TeamsValue{}.AttributeTypes(ctx),
				},
			},
		)
	}

	attributeTypes := map[string]attr.Type{
		"doer": basetypes.ObjectType{
			AttrTypes: DoerValue{}.AttributeTypes(ctx),
		},
		"recipient": basetypes.ObjectType{
			AttrTypes: RecipientValue{}.AttributeTypes(ctx),
		},
		"teams": basetypes.ListType{
			ElemType: TeamsValue{}.Type(ctx),
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"doer":      doer,
			"recipient": recipient,
			"teams":     teams,
		})

	return objVal, diags
}

func (v RepoTransferValue) Equal(o attr.Value) bool {
	other, ok := o.(RepoTransferValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Doer.Equal(other.Doer) {
		return false
	}

	if !v.Recipient.Equal(other.Recipient) {
		return false
	}

	if !v.Teams.Equal(other.Teams) {
		return false
	}

	return true
}

func (v RepoTransferValue) Type(ctx context.Context) attr.Type {
	return RepoTransferType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RepoTransferValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"doer": basetypes.ObjectType{
			AttrTypes: DoerValue{}.AttributeTypes(ctx),
		},
		"recipient": basetypes.ObjectType{
			AttrTypes: RecipientValue{}.AttributeTypes(ctx),
		},
		"teams": basetypes.ListType{
			ElemType: TeamsValue{}.Type(ctx),
		},
	}
}

var _ basetypes.ObjectTypable = DoerType{}

type DoerType struct {
	basetypes.ObjectType
}

func (t DoerType) Equal(o attr.Type) bool {
	other, ok := o.(DoerType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t DoerType) String() string {
	return "DoerType"
}

func (t DoerType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	activeAttribute, ok := attributes["active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`active is missing from object`)

		return nil, diags
	}

	activeVal, ok := activeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`active expected to be basetypes.BoolValue, was: %T`, activeAttribute))
	}

	avatarUrlAttribute, ok := attributes["avatar_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`avatar_url is missing from object`)

		return nil, diags
	}

	avatarUrlVal, ok := avatarUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`avatar_url expected to be basetypes.StringValue, was: %T`, avatarUrlAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	followersCountAttribute, ok := attributes["followers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`followers_count is missing from object`)

		return nil, diags
	}

	followersCountVal, ok := followersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`followers_count expected to be basetypes.Int64Value, was: %T`, followersCountAttribute))
	}

	followingCountAttribute, ok := attributes["following_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`following_count is missing from object`)

		return nil, diags
	}

	followingCountVal, ok := followingCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`following_count expected to be basetypes.Int64Value, was: %T`, followingCountAttribute))
	}

	fullNameAttribute, ok := attributes["full_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_name is missing from object`)

		return nil, diags
	}

	fullNameVal, ok := fullNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_name expected to be basetypes.StringValue, was: %T`, fullNameAttribute))
	}

	htmlUrlAttribute, ok := attributes["html_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`html_url is missing from object`)

		return nil, diags
	}

	htmlUrlVal, ok := htmlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`html_url expected to be basetypes.StringValue, was: %T`, htmlUrlAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	isAdminAttribute, ok := attributes["is_admin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_admin is missing from object`)

		return nil, diags
	}

	isAdminVal, ok := isAdminAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_admin expected to be basetypes.BoolValue, was: %T`, isAdminAttribute))
	}

	languageAttribute, ok := attributes["language"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`language is missing from object`)

		return nil, diags
	}

	languageVal, ok := languageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`language expected to be basetypes.StringValue, was: %T`, languageAttribute))
	}

	lastLoginAttribute, ok := attributes["last_login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_login is missing from object`)

		return nil, diags
	}

	lastLoginVal, ok := lastLoginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_login expected to be basetypes.StringValue, was: %T`, lastLoginAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return nil, diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	loginAttribute, ok := attributes["login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`login is missing from object`)

		return nil, diags
	}

	loginVal, ok := loginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`login expected to be basetypes.StringValue, was: %T`, loginAttribute))
	}

	loginNameAttribute, ok := attributes["login_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`login_name is missing from object`)

		return nil, diags
	}

	loginNameVal, ok := loginNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`login_name expected to be basetypes.StringValue, was: %T`, loginNameAttribute))
	}

	prohibitLoginAttribute, ok := attributes["prohibit_login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prohibit_login is missing from object`)

		return nil, diags
	}

	prohibitLoginVal, ok := prohibitLoginAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prohibit_login expected to be basetypes.BoolValue, was: %T`, prohibitLoginAttribute))
	}

	restrictedAttribute, ok := attributes["restricted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted is missing from object`)

		return nil, diags
	}

	restrictedVal, ok := restrictedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted expected to be basetypes.BoolValue, was: %T`, restrictedAttribute))
	}

	sourceIdAttribute, ok := attributes["source_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_id is missing from object`)

		return nil, diags
	}

	sourceIdVal, ok := sourceIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_id expected to be basetypes.Int64Value, was: %T`, sourceIdAttribute))
	}

	starredReposCountAttribute, ok := attributes["starred_repos_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`starred_repos_count is missing from object`)

		return nil, diags
	}

	starredReposCountVal, ok := starredReposCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`starred_repos_count expected to be basetypes.Int64Value, was: %T`, starredReposCountAttribute))
	}

	visibilityAttribute, ok := attributes["visibility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`visibility is missing from object`)

		return nil, diags
	}

	visibilityVal, ok := visibilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`visibility expected to be basetypes.StringValue, was: %T`, visibilityAttribute))
	}

	websiteAttribute, ok := attributes["website"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`website is missing from object`)

		return nil, diags
	}

	websiteVal, ok := websiteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`website expected to be basetypes.StringValue, was: %T`, websiteAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return DoerValue{
		Active:            activeVal,
		AvatarUrl:         avatarUrlVal,
		Created:           createdVal,
		Description:       descriptionVal,
		Email:             emailVal,
		FollowersCount:    followersCountVal,
		FollowingCount:    followingCountVal,
		FullName:          fullNameVal,
		HtmlUrl:           htmlUrlVal,
		Id:                idVal,
		IsAdmin:           isAdminVal,
		Language:          languageVal,
		LastLogin:         lastLoginVal,
		Location:          locationVal,
		Login:             loginVal,
		LoginName:         loginNameVal,
		ProhibitLogin:     prohibitLoginVal,
		Restricted:        restrictedVal,
		SourceId:          sourceIdVal,
		StarredReposCount: starredReposCountVal,
		Visibility:        visibilityVal,
		Website:           websiteVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDoerValueNull() DoerValue {
	return DoerValue{
		state: attr.ValueStateNull,
	}
}

func NewDoerValueUnknown() DoerValue {
	return DoerValue{
		state: attr.ValueStateUnknown,
	}
}

func NewDoerValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (DoerValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing DoerValue Attribute Value",
				"While creating a DoerValue value, a missing attribute value was detected. "+
					"A DoerValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DoerValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid DoerValue Attribute Type",
				"While creating a DoerValue value, an invalid attribute value was detected. "+
					"A DoerValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("DoerValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("DoerValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra DoerValue Attribute Value",
				"While creating a DoerValue value, an extra attribute value was detected. "+
					"A DoerValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra DoerValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewDoerValueUnknown(), diags
	}

	activeAttribute, ok := attributes["active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`active is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	activeVal, ok := activeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`active expected to be basetypes.BoolValue, was: %T`, activeAttribute))
	}

	avatarUrlAttribute, ok := attributes["avatar_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`avatar_url is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	avatarUrlVal, ok := avatarUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`avatar_url expected to be basetypes.StringValue, was: %T`, avatarUrlAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	followersCountAttribute, ok := attributes["followers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`followers_count is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	followersCountVal, ok := followersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`followers_count expected to be basetypes.Int64Value, was: %T`, followersCountAttribute))
	}

	followingCountAttribute, ok := attributes["following_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`following_count is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	followingCountVal, ok := followingCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`following_count expected to be basetypes.Int64Value, was: %T`, followingCountAttribute))
	}

	fullNameAttribute, ok := attributes["full_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_name is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	fullNameVal, ok := fullNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_name expected to be basetypes.StringValue, was: %T`, fullNameAttribute))
	}

	htmlUrlAttribute, ok := attributes["html_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`html_url is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	htmlUrlVal, ok := htmlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`html_url expected to be basetypes.StringValue, was: %T`, htmlUrlAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	isAdminAttribute, ok := attributes["is_admin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_admin is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	isAdminVal, ok := isAdminAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_admin expected to be basetypes.BoolValue, was: %T`, isAdminAttribute))
	}

	languageAttribute, ok := attributes["language"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`language is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	languageVal, ok := languageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`language expected to be basetypes.StringValue, was: %T`, languageAttribute))
	}

	lastLoginAttribute, ok := attributes["last_login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_login is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	lastLoginVal, ok := lastLoginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_login expected to be basetypes.StringValue, was: %T`, lastLoginAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	loginAttribute, ok := attributes["login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`login is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	loginVal, ok := loginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`login expected to be basetypes.StringValue, was: %T`, loginAttribute))
	}

	loginNameAttribute, ok := attributes["login_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`login_name is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	loginNameVal, ok := loginNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`login_name expected to be basetypes.StringValue, was: %T`, loginNameAttribute))
	}

	prohibitLoginAttribute, ok := attributes["prohibit_login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prohibit_login is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	prohibitLoginVal, ok := prohibitLoginAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prohibit_login expected to be basetypes.BoolValue, was: %T`, prohibitLoginAttribute))
	}

	restrictedAttribute, ok := attributes["restricted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	restrictedVal, ok := restrictedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted expected to be basetypes.BoolValue, was: %T`, restrictedAttribute))
	}

	sourceIdAttribute, ok := attributes["source_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_id is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	sourceIdVal, ok := sourceIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_id expected to be basetypes.Int64Value, was: %T`, sourceIdAttribute))
	}

	starredReposCountAttribute, ok := attributes["starred_repos_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`starred_repos_count is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	starredReposCountVal, ok := starredReposCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`starred_repos_count expected to be basetypes.Int64Value, was: %T`, starredReposCountAttribute))
	}

	visibilityAttribute, ok := attributes["visibility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`visibility is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	visibilityVal, ok := visibilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`visibility expected to be basetypes.StringValue, was: %T`, visibilityAttribute))
	}

	websiteAttribute, ok := attributes["website"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`website is missing from object`)

		return NewDoerValueUnknown(), diags
	}

	websiteVal, ok := websiteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`website expected to be basetypes.StringValue, was: %T`, websiteAttribute))
	}

	if diags.HasError() {
		return NewDoerValueUnknown(), diags
	}

	return DoerValue{
		Active:            activeVal,
		AvatarUrl:         avatarUrlVal,
		Created:           createdVal,
		Description:       descriptionVal,
		Email:             emailVal,
		FollowersCount:    followersCountVal,
		FollowingCount:    followingCountVal,
		FullName:          fullNameVal,
		HtmlUrl:           htmlUrlVal,
		Id:                idVal,
		IsAdmin:           isAdminVal,
		Language:          languageVal,
		LastLogin:         lastLoginVal,
		Location:          locationVal,
		Login:             loginVal,
		LoginName:         loginNameVal,
		ProhibitLogin:     prohibitLoginVal,
		Restricted:        restrictedVal,
		SourceId:          sourceIdVal,
		StarredReposCount: starredReposCountVal,
		Visibility:        visibilityVal,
		Website:           websiteVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewDoerValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) DoerValue {
	object, diags := NewDoerValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewDoerValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t DoerType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewDoerValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewDoerValueUnknown(), nil
	}

	if in.IsNull() {
		return NewDoerValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewDoerValueMust(DoerValue{}.AttributeTypes(ctx), attributes), nil
}

func (t DoerType) ValueType(ctx context.Context) attr.Value {
	return DoerValue{}
}

var _ basetypes.ObjectValuable = DoerValue{}

type DoerValue struct {
	Active            basetypes.BoolValue   `tfsdk:"active"`
	AvatarUrl         basetypes.StringValue `tfsdk:"avatar_url"`
	Created           basetypes.StringValue `tfsdk:"created"`
	Description       basetypes.StringValue `tfsdk:"description"`
	Email             basetypes.StringValue `tfsdk:"email"`
	FollowersCount    basetypes.Int64Value  `tfsdk:"followers_count"`
	FollowingCount    basetypes.Int64Value  `tfsdk:"following_count"`
	FullName          basetypes.StringValue `tfsdk:"full_name"`
	HtmlUrl           basetypes.StringValue `tfsdk:"html_url"`
	Id                basetypes.Int64Value  `tfsdk:"id"`
	IsAdmin           basetypes.BoolValue   `tfsdk:"is_admin"`
	Language          basetypes.StringValue `tfsdk:"language"`
	LastLogin         basetypes.StringValue `tfsdk:"last_login"`
	Location          basetypes.StringValue `tfsdk:"location"`
	Login             basetypes.StringValue `tfsdk:"login"`
	LoginName         basetypes.StringValue `tfsdk:"login_name"`
	ProhibitLogin     basetypes.BoolValue   `tfsdk:"prohibit_login"`
	Restricted        basetypes.BoolValue   `tfsdk:"restricted"`
	SourceId          basetypes.Int64Value  `tfsdk:"source_id"`
	StarredReposCount basetypes.Int64Value  `tfsdk:"starred_repos_count"`
	Visibility        basetypes.StringValue `tfsdk:"visibility"`
	Website           basetypes.StringValue `tfsdk:"website"`
	state             attr.ValueState
}

func (v DoerValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 22)

	var val tftypes.Value
	var err error

	attrTypes["active"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["avatar_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["followers_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["following_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["full_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["html_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["is_admin"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["language"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_login"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["login"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["login_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prohibit_login"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["restricted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["source_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["starred_repos_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["visibility"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["website"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 22)

		val, err = v.Active.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["active"] = val

		val, err = v.AvatarUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["avatar_url"] = val

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.FollowersCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["followers_count"] = val

		val, err = v.FollowingCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["following_count"] = val

		val, err = v.FullName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full_name"] = val

		val, err = v.HtmlUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["html_url"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.IsAdmin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_admin"] = val

		val, err = v.Language.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["language"] = val

		val, err = v.LastLogin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_login"] = val

		val, err = v.Location.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["location"] = val

		val, err = v.Login.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["login"] = val

		val, err = v.LoginName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["login_name"] = val

		val, err = v.ProhibitLogin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prohibit_login"] = val

		val, err = v.Restricted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["restricted"] = val

		val, err = v.SourceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_id"] = val

		val, err = v.StarredReposCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["starred_repos_count"] = val

		val, err = v.Visibility.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["visibility"] = val

		val, err = v.Website.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["website"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v DoerValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v DoerValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v DoerValue) String() string {
	return "DoerValue"
}

func (v DoerValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"active":              basetypes.BoolType{},
		"avatar_url":          basetypes.StringType{},
		"created":             basetypes.StringType{},
		"description":         basetypes.StringType{},
		"email":               basetypes.StringType{},
		"followers_count":     basetypes.Int64Type{},
		"following_count":     basetypes.Int64Type{},
		"full_name":           basetypes.StringType{},
		"html_url":            basetypes.StringType{},
		"id":                  basetypes.Int64Type{},
		"is_admin":            basetypes.BoolType{},
		"language":            basetypes.StringType{},
		"last_login":          basetypes.StringType{},
		"location":            basetypes.StringType{},
		"login":               basetypes.StringType{},
		"login_name":          basetypes.StringType{},
		"prohibit_login":      basetypes.BoolType{},
		"restricted":          basetypes.BoolType{},
		"source_id":           basetypes.Int64Type{},
		"starred_repos_count": basetypes.Int64Type{},
		"visibility":          basetypes.StringType{},
		"website":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"active":              v.Active,
			"avatar_url":          v.AvatarUrl,
			"created":             v.Created,
			"description":         v.Description,
			"email":               v.Email,
			"followers_count":     v.FollowersCount,
			"following_count":     v.FollowingCount,
			"full_name":           v.FullName,
			"html_url":            v.HtmlUrl,
			"id":                  v.Id,
			"is_admin":            v.IsAdmin,
			"language":            v.Language,
			"last_login":          v.LastLogin,
			"location":            v.Location,
			"login":               v.Login,
			"login_name":          v.LoginName,
			"prohibit_login":      v.ProhibitLogin,
			"restricted":          v.Restricted,
			"source_id":           v.SourceId,
			"starred_repos_count": v.StarredReposCount,
			"visibility":          v.Visibility,
			"website":             v.Website,
		})

	return objVal, diags
}

func (v DoerValue) Equal(o attr.Value) bool {
	other, ok := o.(DoerValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Active.Equal(other.Active) {
		return false
	}

	if !v.AvatarUrl.Equal(other.AvatarUrl) {
		return false
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.FollowersCount.Equal(other.FollowersCount) {
		return false
	}

	if !v.FollowingCount.Equal(other.FollowingCount) {
		return false
	}

	if !v.FullName.Equal(other.FullName) {
		return false
	}

	if !v.HtmlUrl.Equal(other.HtmlUrl) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.IsAdmin.Equal(other.IsAdmin) {
		return false
	}

	if !v.Language.Equal(other.Language) {
		return false
	}

	if !v.LastLogin.Equal(other.LastLogin) {
		return false
	}

	if !v.Location.Equal(other.Location) {
		return false
	}

	if !v.Login.Equal(other.Login) {
		return false
	}

	if !v.LoginName.Equal(other.LoginName) {
		return false
	}

	if !v.ProhibitLogin.Equal(other.ProhibitLogin) {
		return false
	}

	if !v.Restricted.Equal(other.Restricted) {
		return false
	}

	if !v.SourceId.Equal(other.SourceId) {
		return false
	}

	if !v.StarredReposCount.Equal(other.StarredReposCount) {
		return false
	}

	if !v.Visibility.Equal(other.Visibility) {
		return false
	}

	if !v.Website.Equal(other.Website) {
		return false
	}

	return true
}

func (v DoerValue) Type(ctx context.Context) attr.Type {
	return DoerType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v DoerValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"active":              basetypes.BoolType{},
		"avatar_url":          basetypes.StringType{},
		"created":             basetypes.StringType{},
		"description":         basetypes.StringType{},
		"email":               basetypes.StringType{},
		"followers_count":     basetypes.Int64Type{},
		"following_count":     basetypes.Int64Type{},
		"full_name":           basetypes.StringType{},
		"html_url":            basetypes.StringType{},
		"id":                  basetypes.Int64Type{},
		"is_admin":            basetypes.BoolType{},
		"language":            basetypes.StringType{},
		"last_login":          basetypes.StringType{},
		"location":            basetypes.StringType{},
		"login":               basetypes.StringType{},
		"login_name":          basetypes.StringType{},
		"prohibit_login":      basetypes.BoolType{},
		"restricted":          basetypes.BoolType{},
		"source_id":           basetypes.Int64Type{},
		"starred_repos_count": basetypes.Int64Type{},
		"visibility":          basetypes.StringType{},
		"website":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = RecipientType{}

type RecipientType struct {
	basetypes.ObjectType
}

func (t RecipientType) Equal(o attr.Type) bool {
	other, ok := o.(RecipientType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t RecipientType) String() string {
	return "RecipientType"
}

func (t RecipientType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	activeAttribute, ok := attributes["active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`active is missing from object`)

		return nil, diags
	}

	activeVal, ok := activeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`active expected to be basetypes.BoolValue, was: %T`, activeAttribute))
	}

	avatarUrlAttribute, ok := attributes["avatar_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`avatar_url is missing from object`)

		return nil, diags
	}

	avatarUrlVal, ok := avatarUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`avatar_url expected to be basetypes.StringValue, was: %T`, avatarUrlAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return nil, diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	followersCountAttribute, ok := attributes["followers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`followers_count is missing from object`)

		return nil, diags
	}

	followersCountVal, ok := followersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`followers_count expected to be basetypes.Int64Value, was: %T`, followersCountAttribute))
	}

	followingCountAttribute, ok := attributes["following_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`following_count is missing from object`)

		return nil, diags
	}

	followingCountVal, ok := followingCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`following_count expected to be basetypes.Int64Value, was: %T`, followingCountAttribute))
	}

	fullNameAttribute, ok := attributes["full_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_name is missing from object`)

		return nil, diags
	}

	fullNameVal, ok := fullNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_name expected to be basetypes.StringValue, was: %T`, fullNameAttribute))
	}

	htmlUrlAttribute, ok := attributes["html_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`html_url is missing from object`)

		return nil, diags
	}

	htmlUrlVal, ok := htmlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`html_url expected to be basetypes.StringValue, was: %T`, htmlUrlAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	isAdminAttribute, ok := attributes["is_admin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_admin is missing from object`)

		return nil, diags
	}

	isAdminVal, ok := isAdminAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_admin expected to be basetypes.BoolValue, was: %T`, isAdminAttribute))
	}

	languageAttribute, ok := attributes["language"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`language is missing from object`)

		return nil, diags
	}

	languageVal, ok := languageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`language expected to be basetypes.StringValue, was: %T`, languageAttribute))
	}

	lastLoginAttribute, ok := attributes["last_login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_login is missing from object`)

		return nil, diags
	}

	lastLoginVal, ok := lastLoginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_login expected to be basetypes.StringValue, was: %T`, lastLoginAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return nil, diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	loginAttribute, ok := attributes["login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`login is missing from object`)

		return nil, diags
	}

	loginVal, ok := loginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`login expected to be basetypes.StringValue, was: %T`, loginAttribute))
	}

	loginNameAttribute, ok := attributes["login_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`login_name is missing from object`)

		return nil, diags
	}

	loginNameVal, ok := loginNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`login_name expected to be basetypes.StringValue, was: %T`, loginNameAttribute))
	}

	prohibitLoginAttribute, ok := attributes["prohibit_login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prohibit_login is missing from object`)

		return nil, diags
	}

	prohibitLoginVal, ok := prohibitLoginAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prohibit_login expected to be basetypes.BoolValue, was: %T`, prohibitLoginAttribute))
	}

	restrictedAttribute, ok := attributes["restricted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted is missing from object`)

		return nil, diags
	}

	restrictedVal, ok := restrictedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted expected to be basetypes.BoolValue, was: %T`, restrictedAttribute))
	}

	sourceIdAttribute, ok := attributes["source_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_id is missing from object`)

		return nil, diags
	}

	sourceIdVal, ok := sourceIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_id expected to be basetypes.Int64Value, was: %T`, sourceIdAttribute))
	}

	starredReposCountAttribute, ok := attributes["starred_repos_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`starred_repos_count is missing from object`)

		return nil, diags
	}

	starredReposCountVal, ok := starredReposCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`starred_repos_count expected to be basetypes.Int64Value, was: %T`, starredReposCountAttribute))
	}

	visibilityAttribute, ok := attributes["visibility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`visibility is missing from object`)

		return nil, diags
	}

	visibilityVal, ok := visibilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`visibility expected to be basetypes.StringValue, was: %T`, visibilityAttribute))
	}

	websiteAttribute, ok := attributes["website"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`website is missing from object`)

		return nil, diags
	}

	websiteVal, ok := websiteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`website expected to be basetypes.StringValue, was: %T`, websiteAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return RecipientValue{
		Active:            activeVal,
		AvatarUrl:         avatarUrlVal,
		Created:           createdVal,
		Description:       descriptionVal,
		Email:             emailVal,
		FollowersCount:    followersCountVal,
		FollowingCount:    followingCountVal,
		FullName:          fullNameVal,
		HtmlUrl:           htmlUrlVal,
		Id:                idVal,
		IsAdmin:           isAdminVal,
		Language:          languageVal,
		LastLogin:         lastLoginVal,
		Location:          locationVal,
		Login:             loginVal,
		LoginName:         loginNameVal,
		ProhibitLogin:     prohibitLoginVal,
		Restricted:        restrictedVal,
		SourceId:          sourceIdVal,
		StarredReposCount: starredReposCountVal,
		Visibility:        visibilityVal,
		Website:           websiteVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRecipientValueNull() RecipientValue {
	return RecipientValue{
		state: attr.ValueStateNull,
	}
}

func NewRecipientValueUnknown() RecipientValue {
	return RecipientValue{
		state: attr.ValueStateUnknown,
	}
}

func NewRecipientValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (RecipientValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing RecipientValue Attribute Value",
				"While creating a RecipientValue value, a missing attribute value was detected. "+
					"A RecipientValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RecipientValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid RecipientValue Attribute Type",
				"While creating a RecipientValue value, an invalid attribute value was detected. "+
					"A RecipientValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("RecipientValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("RecipientValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra RecipientValue Attribute Value",
				"While creating a RecipientValue value, an extra attribute value was detected. "+
					"A RecipientValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra RecipientValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewRecipientValueUnknown(), diags
	}

	activeAttribute, ok := attributes["active"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`active is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	activeVal, ok := activeAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`active expected to be basetypes.BoolValue, was: %T`, activeAttribute))
	}

	avatarUrlAttribute, ok := attributes["avatar_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`avatar_url is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	avatarUrlVal, ok := avatarUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`avatar_url expected to be basetypes.StringValue, was: %T`, avatarUrlAttribute))
	}

	createdAttribute, ok := attributes["created"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`created is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	createdVal, ok := createdAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`created expected to be basetypes.StringValue, was: %T`, createdAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	followersCountAttribute, ok := attributes["followers_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`followers_count is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	followersCountVal, ok := followersCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`followers_count expected to be basetypes.Int64Value, was: %T`, followersCountAttribute))
	}

	followingCountAttribute, ok := attributes["following_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`following_count is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	followingCountVal, ok := followingCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`following_count expected to be basetypes.Int64Value, was: %T`, followingCountAttribute))
	}

	fullNameAttribute, ok := attributes["full_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_name is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	fullNameVal, ok := fullNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_name expected to be basetypes.StringValue, was: %T`, fullNameAttribute))
	}

	htmlUrlAttribute, ok := attributes["html_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`html_url is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	htmlUrlVal, ok := htmlUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`html_url expected to be basetypes.StringValue, was: %T`, htmlUrlAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	isAdminAttribute, ok := attributes["is_admin"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`is_admin is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	isAdminVal, ok := isAdminAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`is_admin expected to be basetypes.BoolValue, was: %T`, isAdminAttribute))
	}

	languageAttribute, ok := attributes["language"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`language is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	languageVal, ok := languageAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`language expected to be basetypes.StringValue, was: %T`, languageAttribute))
	}

	lastLoginAttribute, ok := attributes["last_login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`last_login is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	lastLoginVal, ok := lastLoginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`last_login expected to be basetypes.StringValue, was: %T`, lastLoginAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	loginAttribute, ok := attributes["login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`login is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	loginVal, ok := loginAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`login expected to be basetypes.StringValue, was: %T`, loginAttribute))
	}

	loginNameAttribute, ok := attributes["login_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`login_name is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	loginNameVal, ok := loginNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`login_name expected to be basetypes.StringValue, was: %T`, loginNameAttribute))
	}

	prohibitLoginAttribute, ok := attributes["prohibit_login"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`prohibit_login is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	prohibitLoginVal, ok := prohibitLoginAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`prohibit_login expected to be basetypes.BoolValue, was: %T`, prohibitLoginAttribute))
	}

	restrictedAttribute, ok := attributes["restricted"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`restricted is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	restrictedVal, ok := restrictedAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`restricted expected to be basetypes.BoolValue, was: %T`, restrictedAttribute))
	}

	sourceIdAttribute, ok := attributes["source_id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`source_id is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	sourceIdVal, ok := sourceIdAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`source_id expected to be basetypes.Int64Value, was: %T`, sourceIdAttribute))
	}

	starredReposCountAttribute, ok := attributes["starred_repos_count"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`starred_repos_count is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	starredReposCountVal, ok := starredReposCountAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`starred_repos_count expected to be basetypes.Int64Value, was: %T`, starredReposCountAttribute))
	}

	visibilityAttribute, ok := attributes["visibility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`visibility is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	visibilityVal, ok := visibilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`visibility expected to be basetypes.StringValue, was: %T`, visibilityAttribute))
	}

	websiteAttribute, ok := attributes["website"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`website is missing from object`)

		return NewRecipientValueUnknown(), diags
	}

	websiteVal, ok := websiteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`website expected to be basetypes.StringValue, was: %T`, websiteAttribute))
	}

	if diags.HasError() {
		return NewRecipientValueUnknown(), diags
	}

	return RecipientValue{
		Active:            activeVal,
		AvatarUrl:         avatarUrlVal,
		Created:           createdVal,
		Description:       descriptionVal,
		Email:             emailVal,
		FollowersCount:    followersCountVal,
		FollowingCount:    followingCountVal,
		FullName:          fullNameVal,
		HtmlUrl:           htmlUrlVal,
		Id:                idVal,
		IsAdmin:           isAdminVal,
		Language:          languageVal,
		LastLogin:         lastLoginVal,
		Location:          locationVal,
		Login:             loginVal,
		LoginName:         loginNameVal,
		ProhibitLogin:     prohibitLoginVal,
		Restricted:        restrictedVal,
		SourceId:          sourceIdVal,
		StarredReposCount: starredReposCountVal,
		Visibility:        visibilityVal,
		Website:           websiteVal,
		state:             attr.ValueStateKnown,
	}, diags
}

func NewRecipientValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) RecipientValue {
	object, diags := NewRecipientValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewRecipientValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t RecipientType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewRecipientValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewRecipientValueUnknown(), nil
	}

	if in.IsNull() {
		return NewRecipientValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewRecipientValueMust(RecipientValue{}.AttributeTypes(ctx), attributes), nil
}

func (t RecipientType) ValueType(ctx context.Context) attr.Value {
	return RecipientValue{}
}

var _ basetypes.ObjectValuable = RecipientValue{}

type RecipientValue struct {
	Active            basetypes.BoolValue   `tfsdk:"active"`
	AvatarUrl         basetypes.StringValue `tfsdk:"avatar_url"`
	Created           basetypes.StringValue `tfsdk:"created"`
	Description       basetypes.StringValue `tfsdk:"description"`
	Email             basetypes.StringValue `tfsdk:"email"`
	FollowersCount    basetypes.Int64Value  `tfsdk:"followers_count"`
	FollowingCount    basetypes.Int64Value  `tfsdk:"following_count"`
	FullName          basetypes.StringValue `tfsdk:"full_name"`
	HtmlUrl           basetypes.StringValue `tfsdk:"html_url"`
	Id                basetypes.Int64Value  `tfsdk:"id"`
	IsAdmin           basetypes.BoolValue   `tfsdk:"is_admin"`
	Language          basetypes.StringValue `tfsdk:"language"`
	LastLogin         basetypes.StringValue `tfsdk:"last_login"`
	Location          basetypes.StringValue `tfsdk:"location"`
	Login             basetypes.StringValue `tfsdk:"login"`
	LoginName         basetypes.StringValue `tfsdk:"login_name"`
	ProhibitLogin     basetypes.BoolValue   `tfsdk:"prohibit_login"`
	Restricted        basetypes.BoolValue   `tfsdk:"restricted"`
	SourceId          basetypes.Int64Value  `tfsdk:"source_id"`
	StarredReposCount basetypes.Int64Value  `tfsdk:"starred_repos_count"`
	Visibility        basetypes.StringValue `tfsdk:"visibility"`
	Website           basetypes.StringValue `tfsdk:"website"`
	state             attr.ValueState
}

func (v RecipientValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 22)

	var val tftypes.Value
	var err error

	attrTypes["active"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["avatar_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["created"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["followers_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["following_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["full_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["html_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["is_admin"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["language"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["last_login"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["login"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["login_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["prohibit_login"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["restricted"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["source_id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["starred_repos_count"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["visibility"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["website"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 22)

		val, err = v.Active.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["active"] = val

		val, err = v.AvatarUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["avatar_url"] = val

		val, err = v.Created.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["created"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.FollowersCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["followers_count"] = val

		val, err = v.FollowingCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["following_count"] = val

		val, err = v.FullName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full_name"] = val

		val, err = v.HtmlUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["html_url"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.IsAdmin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["is_admin"] = val

		val, err = v.Language.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["language"] = val

		val, err = v.LastLogin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["last_login"] = val

		val, err = v.Location.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["location"] = val

		val, err = v.Login.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["login"] = val

		val, err = v.LoginName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["login_name"] = val

		val, err = v.ProhibitLogin.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["prohibit_login"] = val

		val, err = v.Restricted.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["restricted"] = val

		val, err = v.SourceId.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["source_id"] = val

		val, err = v.StarredReposCount.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["starred_repos_count"] = val

		val, err = v.Visibility.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["visibility"] = val

		val, err = v.Website.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["website"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v RecipientValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v RecipientValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v RecipientValue) String() string {
	return "RecipientValue"
}

func (v RecipientValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"active":              basetypes.BoolType{},
		"avatar_url":          basetypes.StringType{},
		"created":             basetypes.StringType{},
		"description":         basetypes.StringType{},
		"email":               basetypes.StringType{},
		"followers_count":     basetypes.Int64Type{},
		"following_count":     basetypes.Int64Type{},
		"full_name":           basetypes.StringType{},
		"html_url":            basetypes.StringType{},
		"id":                  basetypes.Int64Type{},
		"is_admin":            basetypes.BoolType{},
		"language":            basetypes.StringType{},
		"last_login":          basetypes.StringType{},
		"location":            basetypes.StringType{},
		"login":               basetypes.StringType{},
		"login_name":          basetypes.StringType{},
		"prohibit_login":      basetypes.BoolType{},
		"restricted":          basetypes.BoolType{},
		"source_id":           basetypes.Int64Type{},
		"starred_repos_count": basetypes.Int64Type{},
		"visibility":          basetypes.StringType{},
		"website":             basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"active":              v.Active,
			"avatar_url":          v.AvatarUrl,
			"created":             v.Created,
			"description":         v.Description,
			"email":               v.Email,
			"followers_count":     v.FollowersCount,
			"following_count":     v.FollowingCount,
			"full_name":           v.FullName,
			"html_url":            v.HtmlUrl,
			"id":                  v.Id,
			"is_admin":            v.IsAdmin,
			"language":            v.Language,
			"last_login":          v.LastLogin,
			"location":            v.Location,
			"login":               v.Login,
			"login_name":          v.LoginName,
			"prohibit_login":      v.ProhibitLogin,
			"restricted":          v.Restricted,
			"source_id":           v.SourceId,
			"starred_repos_count": v.StarredReposCount,
			"visibility":          v.Visibility,
			"website":             v.Website,
		})

	return objVal, diags
}

func (v RecipientValue) Equal(o attr.Value) bool {
	other, ok := o.(RecipientValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.Active.Equal(other.Active) {
		return false
	}

	if !v.AvatarUrl.Equal(other.AvatarUrl) {
		return false
	}

	if !v.Created.Equal(other.Created) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.FollowersCount.Equal(other.FollowersCount) {
		return false
	}

	if !v.FollowingCount.Equal(other.FollowingCount) {
		return false
	}

	if !v.FullName.Equal(other.FullName) {
		return false
	}

	if !v.HtmlUrl.Equal(other.HtmlUrl) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.IsAdmin.Equal(other.IsAdmin) {
		return false
	}

	if !v.Language.Equal(other.Language) {
		return false
	}

	if !v.LastLogin.Equal(other.LastLogin) {
		return false
	}

	if !v.Location.Equal(other.Location) {
		return false
	}

	if !v.Login.Equal(other.Login) {
		return false
	}

	if !v.LoginName.Equal(other.LoginName) {
		return false
	}

	if !v.ProhibitLogin.Equal(other.ProhibitLogin) {
		return false
	}

	if !v.Restricted.Equal(other.Restricted) {
		return false
	}

	if !v.SourceId.Equal(other.SourceId) {
		return false
	}

	if !v.StarredReposCount.Equal(other.StarredReposCount) {
		return false
	}

	if !v.Visibility.Equal(other.Visibility) {
		return false
	}

	if !v.Website.Equal(other.Website) {
		return false
	}

	return true
}

func (v RecipientValue) Type(ctx context.Context) attr.Type {
	return RecipientType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v RecipientValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"active":              basetypes.BoolType{},
		"avatar_url":          basetypes.StringType{},
		"created":             basetypes.StringType{},
		"description":         basetypes.StringType{},
		"email":               basetypes.StringType{},
		"followers_count":     basetypes.Int64Type{},
		"following_count":     basetypes.Int64Type{},
		"full_name":           basetypes.StringType{},
		"html_url":            basetypes.StringType{},
		"id":                  basetypes.Int64Type{},
		"is_admin":            basetypes.BoolType{},
		"language":            basetypes.StringType{},
		"last_login":          basetypes.StringType{},
		"location":            basetypes.StringType{},
		"login":               basetypes.StringType{},
		"login_name":          basetypes.StringType{},
		"prohibit_login":      basetypes.BoolType{},
		"restricted":          basetypes.BoolType{},
		"source_id":           basetypes.Int64Type{},
		"starred_repos_count": basetypes.Int64Type{},
		"visibility":          basetypes.StringType{},
		"website":             basetypes.StringType{},
	}
}

var _ basetypes.ObjectTypable = TeamsType{}

type TeamsType struct {
	basetypes.ObjectType
}

func (t TeamsType) Equal(o attr.Type) bool {
	other, ok := o.(TeamsType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t TeamsType) String() string {
	return "TeamsType"
}

func (t TeamsType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	canCreateOrgRepoAttribute, ok := attributes["can_create_org_repo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`can_create_org_repo is missing from object`)

		return nil, diags
	}

	canCreateOrgRepoVal, ok := canCreateOrgRepoAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`can_create_org_repo expected to be basetypes.BoolValue, was: %T`, canCreateOrgRepoAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	includesAllRepositoriesAttribute, ok := attributes["includes_all_repositories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`includes_all_repositories is missing from object`)

		return nil, diags
	}

	includesAllRepositoriesVal, ok := includesAllRepositoriesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`includes_all_repositories expected to be basetypes.BoolValue, was: %T`, includesAllRepositoriesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	organizationAttribute, ok := attributes["organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization is missing from object`)

		return nil, diags
	}

	organizationVal, ok := organizationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization expected to be basetypes.ObjectValue, was: %T`, organizationAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return nil, diags
	}

	permissionVal, ok := permissionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be basetypes.StringValue, was: %T`, permissionAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return nil, diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.ListValue, was: %T`, unitsAttribute))
	}

	unitsMapAttribute, ok := attributes["units_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units_map is missing from object`)

		return nil, diags
	}

	unitsMapVal, ok := unitsMapAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units_map expected to be basetypes.MapValue, was: %T`, unitsMapAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return TeamsValue{
		CanCreateOrgRepo:        canCreateOrgRepoVal,
		Description:             descriptionVal,
		Id:                      idVal,
		IncludesAllRepositories: includesAllRepositoriesVal,
		Name:                    nameVal,
		Organization:            organizationVal,
		Permission:              permissionVal,
		Units:                   unitsVal,
		UnitsMap:                unitsMapVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewTeamsValueNull() TeamsValue {
	return TeamsValue{
		state: attr.ValueStateNull,
	}
}

func NewTeamsValueUnknown() TeamsValue {
	return TeamsValue{
		state: attr.ValueStateUnknown,
	}
}

func NewTeamsValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (TeamsValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing TeamsValue Attribute Value",
				"While creating a TeamsValue value, a missing attribute value was detected. "+
					"A TeamsValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TeamsValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid TeamsValue Attribute Type",
				"While creating a TeamsValue value, an invalid attribute value was detected. "+
					"A TeamsValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("TeamsValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("TeamsValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra TeamsValue Attribute Value",
				"While creating a TeamsValue value, an extra attribute value was detected. "+
					"A TeamsValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra TeamsValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewTeamsValueUnknown(), diags
	}

	canCreateOrgRepoAttribute, ok := attributes["can_create_org_repo"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`can_create_org_repo is missing from object`)

		return NewTeamsValueUnknown(), diags
	}

	canCreateOrgRepoVal, ok := canCreateOrgRepoAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`can_create_org_repo expected to be basetypes.BoolValue, was: %T`, canCreateOrgRepoAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewTeamsValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewTeamsValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	includesAllRepositoriesAttribute, ok := attributes["includes_all_repositories"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`includes_all_repositories is missing from object`)

		return NewTeamsValueUnknown(), diags
	}

	includesAllRepositoriesVal, ok := includesAllRepositoriesAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`includes_all_repositories expected to be basetypes.BoolValue, was: %T`, includesAllRepositoriesAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewTeamsValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	organizationAttribute, ok := attributes["organization"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`organization is missing from object`)

		return NewTeamsValueUnknown(), diags
	}

	organizationVal, ok := organizationAttribute.(basetypes.ObjectValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`organization expected to be basetypes.ObjectValue, was: %T`, organizationAttribute))
	}

	permissionAttribute, ok := attributes["permission"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`permission is missing from object`)

		return NewTeamsValueUnknown(), diags
	}

	permissionVal, ok := permissionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`permission expected to be basetypes.StringValue, was: %T`, permissionAttribute))
	}

	unitsAttribute, ok := attributes["units"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units is missing from object`)

		return NewTeamsValueUnknown(), diags
	}

	unitsVal, ok := unitsAttribute.(basetypes.ListValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units expected to be basetypes.ListValue, was: %T`, unitsAttribute))
	}

	unitsMapAttribute, ok := attributes["units_map"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`units_map is missing from object`)

		return NewTeamsValueUnknown(), diags
	}

	unitsMapVal, ok := unitsMapAttribute.(basetypes.MapValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`units_map expected to be basetypes.MapValue, was: %T`, unitsMapAttribute))
	}

	if diags.HasError() {
		return NewTeamsValueUnknown(), diags
	}

	return TeamsValue{
		CanCreateOrgRepo:        canCreateOrgRepoVal,
		Description:             descriptionVal,
		Id:                      idVal,
		IncludesAllRepositories: includesAllRepositoriesVal,
		Name:                    nameVal,
		Organization:            organizationVal,
		Permission:              permissionVal,
		Units:                   unitsVal,
		UnitsMap:                unitsMapVal,
		state:                   attr.ValueStateKnown,
	}, diags
}

func NewTeamsValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) TeamsValue {
	object, diags := NewTeamsValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewTeamsValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t TeamsType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewTeamsValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewTeamsValueUnknown(), nil
	}

	if in.IsNull() {
		return NewTeamsValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewTeamsValueMust(TeamsValue{}.AttributeTypes(ctx), attributes), nil
}

func (t TeamsType) ValueType(ctx context.Context) attr.Value {
	return TeamsValue{}
}

var _ basetypes.ObjectValuable = TeamsValue{}

type TeamsValue struct {
	CanCreateOrgRepo        basetypes.BoolValue   `tfsdk:"can_create_org_repo"`
	Description             basetypes.StringValue `tfsdk:"description"`
	Id                      basetypes.Int64Value  `tfsdk:"id"`
	IncludesAllRepositories basetypes.BoolValue   `tfsdk:"includes_all_repositories"`
	Name                    basetypes.StringValue `tfsdk:"name"`
	Organization            basetypes.ObjectValue `tfsdk:"organization"`
	Permission              basetypes.StringValue `tfsdk:"permission"`
	Units                   basetypes.ListValue   `tfsdk:"units"`
	UnitsMap                basetypes.MapValue    `tfsdk:"units_map"`
	state                   attr.ValueState
}

func (v TeamsValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 9)

	var val tftypes.Value
	var err error

	attrTypes["can_create_org_repo"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["includes_all_repositories"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["organization"] = basetypes.ObjectType{
		AttrTypes: OrganizationValue{}.AttributeTypes(ctx),
	}.TerraformType(ctx)
	attrTypes["permission"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["units"] = basetypes.ListType{
		ElemType: types.StringType,
	}.TerraformType(ctx)
	attrTypes["units_map"] = basetypes.MapType{
		ElemType: types.StringType,
	}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 9)

		val, err = v.CanCreateOrgRepo.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["can_create_org_repo"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.IncludesAllRepositories.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["includes_all_repositories"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.Organization.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["organization"] = val

		val, err = v.Permission.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["permission"] = val

		val, err = v.Units.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units"] = val

		val, err = v.UnitsMap.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["units_map"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v TeamsValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v TeamsValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v TeamsValue) String() string {
	return "TeamsValue"
}

func (v TeamsValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	var organization basetypes.ObjectValue

	if v.Organization.IsNull() {
		organization = types.ObjectNull(
			OrganizationValue{}.AttributeTypes(ctx),
		)
	}

	if v.Organization.IsUnknown() {
		organization = types.ObjectUnknown(
			OrganizationValue{}.AttributeTypes(ctx),
		)
	}

	if !v.Organization.IsNull() && !v.Organization.IsUnknown() {
		organization = types.ObjectValueMust(
			OrganizationValue{}.AttributeTypes(ctx),
			v.Organization.Attributes(),
		)
	}

	var unitsVal basetypes.ListValue
	switch {
	case v.Units.IsUnknown():
		unitsVal = types.ListUnknown(types.StringType)
	case v.Units.IsNull():
		unitsVal = types.ListNull(types.StringType)
	default:
		var d diag.Diagnostics
		unitsVal, d = types.ListValue(types.StringType, v.Units.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"can_create_org_repo":       basetypes.BoolType{},
			"description":               basetypes.StringType{},
			"id":                        basetypes.Int64Type{},
			"includes_all_repositories": basetypes.BoolType{},
			"name":                      basetypes.StringType{},
			"organization": basetypes.ObjectType{
				AttrTypes: OrganizationValue{}.AttributeTypes(ctx),
			},
			"permission": basetypes.StringType{},
			"units": basetypes.ListType{
				ElemType: types.StringType,
			},
			"units_map": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	var unitsMapVal basetypes.MapValue
	switch {
	case v.UnitsMap.IsUnknown():
		unitsMapVal = types.MapUnknown(types.StringType)
	case v.UnitsMap.IsNull():
		unitsMapVal = types.MapNull(types.StringType)
	default:
		var d diag.Diagnostics
		unitsMapVal, d = types.MapValue(types.StringType, v.UnitsMap.Elements())
		diags.Append(d...)
	}

	if diags.HasError() {
		return types.ObjectUnknown(map[string]attr.Type{
			"can_create_org_repo":       basetypes.BoolType{},
			"description":               basetypes.StringType{},
			"id":                        basetypes.Int64Type{},
			"includes_all_repositories": basetypes.BoolType{},
			"name":                      basetypes.StringType{},
			"organization": basetypes.ObjectType{
				AttrTypes: OrganizationValue{}.AttributeTypes(ctx),
			},
			"permission": basetypes.StringType{},
			"units": basetypes.ListType{
				ElemType: types.StringType,
			},
			"units_map": basetypes.MapType{
				ElemType: types.StringType,
			},
		}), diags
	}

	attributeTypes := map[string]attr.Type{
		"can_create_org_repo":       basetypes.BoolType{},
		"description":               basetypes.StringType{},
		"id":                        basetypes.Int64Type{},
		"includes_all_repositories": basetypes.BoolType{},
		"name":                      basetypes.StringType{},
		"organization": basetypes.ObjectType{
			AttrTypes: OrganizationValue{}.AttributeTypes(ctx),
		},
		"permission": basetypes.StringType{},
		"units": basetypes.ListType{
			ElemType: types.StringType,
		},
		"units_map": basetypes.MapType{
			ElemType: types.StringType,
		},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"can_create_org_repo":       v.CanCreateOrgRepo,
			"description":               v.Description,
			"id":                        v.Id,
			"includes_all_repositories": v.IncludesAllRepositories,
			"name":                      v.Name,
			"organization":              organization,
			"permission":                v.Permission,
			"units":                     unitsVal,
			"units_map":                 unitsMapVal,
		})

	return objVal, diags
}

func (v TeamsValue) Equal(o attr.Value) bool {
	other, ok := o.(TeamsValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.CanCreateOrgRepo.Equal(other.CanCreateOrgRepo) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.IncludesAllRepositories.Equal(other.IncludesAllRepositories) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.Organization.Equal(other.Organization) {
		return false
	}

	if !v.Permission.Equal(other.Permission) {
		return false
	}

	if !v.Units.Equal(other.Units) {
		return false
	}

	if !v.UnitsMap.Equal(other.UnitsMap) {
		return false
	}

	return true
}

func (v TeamsValue) Type(ctx context.Context) attr.Type {
	return TeamsType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v TeamsValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"can_create_org_repo":       basetypes.BoolType{},
		"description":               basetypes.StringType{},
		"id":                        basetypes.Int64Type{},
		"includes_all_repositories": basetypes.BoolType{},
		"name":                      basetypes.StringType{},
		"organization": basetypes.ObjectType{
			AttrTypes: OrganizationValue{}.AttributeTypes(ctx),
		},
		"permission": basetypes.StringType{},
		"units": basetypes.ListType{
			ElemType: types.StringType,
		},
		"units_map": basetypes.MapType{
			ElemType: types.StringType,
		},
	}
}

var _ basetypes.ObjectTypable = OrganizationType{}

type OrganizationType struct {
	basetypes.ObjectType
}

func (t OrganizationType) Equal(o attr.Type) bool {
	other, ok := o.(OrganizationType)

	if !ok {
		return false
	}

	return t.ObjectType.Equal(other.ObjectType)
}

func (t OrganizationType) String() string {
	return "OrganizationType"
}

func (t OrganizationType) ValueFromObject(ctx context.Context, in basetypes.ObjectValue) (basetypes.ObjectValuable, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributes := in.Attributes()

	avatarUrlAttribute, ok := attributes["avatar_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`avatar_url is missing from object`)

		return nil, diags
	}

	avatarUrlVal, ok := avatarUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`avatar_url expected to be basetypes.StringValue, was: %T`, avatarUrlAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return nil, diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return nil, diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	fullNameAttribute, ok := attributes["full_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_name is missing from object`)

		return nil, diags
	}

	fullNameVal, ok := fullNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_name expected to be basetypes.StringValue, was: %T`, fullNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return nil, diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return nil, diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return nil, diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	repoAdminChangeTeamAccessAttribute, ok := attributes["repo_admin_change_team_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`repo_admin_change_team_access is missing from object`)

		return nil, diags
	}

	repoAdminChangeTeamAccessVal, ok := repoAdminChangeTeamAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`repo_admin_change_team_access expected to be basetypes.BoolValue, was: %T`, repoAdminChangeTeamAccessAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return nil, diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	visibilityAttribute, ok := attributes["visibility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`visibility is missing from object`)

		return nil, diags
	}

	visibilityVal, ok := visibilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`visibility expected to be basetypes.StringValue, was: %T`, visibilityAttribute))
	}

	websiteAttribute, ok := attributes["website"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`website is missing from object`)

		return nil, diags
	}

	websiteVal, ok := websiteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`website expected to be basetypes.StringValue, was: %T`, websiteAttribute))
	}

	if diags.HasError() {
		return nil, diags
	}

	return OrganizationValue{
		AvatarUrl:                 avatarUrlVal,
		Description:               descriptionVal,
		Email:                     emailVal,
		FullName:                  fullNameVal,
		Id:                        idVal,
		Location:                  locationVal,
		Name:                      nameVal,
		RepoAdminChangeTeamAccess: repoAdminChangeTeamAccessVal,
		Username:                  usernameVal,
		Visibility:                visibilityVal,
		Website:                   websiteVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewOrganizationValueNull() OrganizationValue {
	return OrganizationValue{
		state: attr.ValueStateNull,
	}
}

func NewOrganizationValueUnknown() OrganizationValue {
	return OrganizationValue{
		state: attr.ValueStateUnknown,
	}
}

func NewOrganizationValue(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) (OrganizationValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	// Reference: https://github.com/hashicorp/terraform-plugin-framework/issues/521
	ctx := context.Background()

	for name, attributeType := range attributeTypes {
		attribute, ok := attributes[name]

		if !ok {
			diags.AddError(
				"Missing OrganizationValue Attribute Value",
				"While creating a OrganizationValue value, a missing attribute value was detected. "+
					"A OrganizationValue must contain values for all attributes, even if null or unknown. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrganizationValue Attribute Name (%s) Expected Type: %s", name, attributeType.String()),
			)

			continue
		}

		if !attributeType.Equal(attribute.Type(ctx)) {
			diags.AddError(
				"Invalid OrganizationValue Attribute Type",
				"While creating a OrganizationValue value, an invalid attribute value was detected. "+
					"A OrganizationValue must use a matching attribute type for the value. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("OrganizationValue Attribute Name (%s) Expected Type: %s\n", name, attributeType.String())+
					fmt.Sprintf("OrganizationValue Attribute Name (%s) Given Type: %s", name, attribute.Type(ctx)),
			)
		}
	}

	for name := range attributes {
		_, ok := attributeTypes[name]

		if !ok {
			diags.AddError(
				"Extra OrganizationValue Attribute Value",
				"While creating a OrganizationValue value, an extra attribute value was detected. "+
					"A OrganizationValue must not contain values beyond the expected attribute types. "+
					"This is always an issue with the provider and should be reported to the provider developers.\n\n"+
					fmt.Sprintf("Extra OrganizationValue Attribute Name: %s", name),
			)
		}
	}

	if diags.HasError() {
		return NewOrganizationValueUnknown(), diags
	}

	avatarUrlAttribute, ok := attributes["avatar_url"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`avatar_url is missing from object`)

		return NewOrganizationValueUnknown(), diags
	}

	avatarUrlVal, ok := avatarUrlAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`avatar_url expected to be basetypes.StringValue, was: %T`, avatarUrlAttribute))
	}

	descriptionAttribute, ok := attributes["description"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`description is missing from object`)

		return NewOrganizationValueUnknown(), diags
	}

	descriptionVal, ok := descriptionAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`description expected to be basetypes.StringValue, was: %T`, descriptionAttribute))
	}

	emailAttribute, ok := attributes["email"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`email is missing from object`)

		return NewOrganizationValueUnknown(), diags
	}

	emailVal, ok := emailAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`email expected to be basetypes.StringValue, was: %T`, emailAttribute))
	}

	fullNameAttribute, ok := attributes["full_name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`full_name is missing from object`)

		return NewOrganizationValueUnknown(), diags
	}

	fullNameVal, ok := fullNameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`full_name expected to be basetypes.StringValue, was: %T`, fullNameAttribute))
	}

	idAttribute, ok := attributes["id"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`id is missing from object`)

		return NewOrganizationValueUnknown(), diags
	}

	idVal, ok := idAttribute.(basetypes.Int64Value)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`id expected to be basetypes.Int64Value, was: %T`, idAttribute))
	}

	locationAttribute, ok := attributes["location"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`location is missing from object`)

		return NewOrganizationValueUnknown(), diags
	}

	locationVal, ok := locationAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`location expected to be basetypes.StringValue, was: %T`, locationAttribute))
	}

	nameAttribute, ok := attributes["name"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`name is missing from object`)

		return NewOrganizationValueUnknown(), diags
	}

	nameVal, ok := nameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`name expected to be basetypes.StringValue, was: %T`, nameAttribute))
	}

	repoAdminChangeTeamAccessAttribute, ok := attributes["repo_admin_change_team_access"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`repo_admin_change_team_access is missing from object`)

		return NewOrganizationValueUnknown(), diags
	}

	repoAdminChangeTeamAccessVal, ok := repoAdminChangeTeamAccessAttribute.(basetypes.BoolValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`repo_admin_change_team_access expected to be basetypes.BoolValue, was: %T`, repoAdminChangeTeamAccessAttribute))
	}

	usernameAttribute, ok := attributes["username"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`username is missing from object`)

		return NewOrganizationValueUnknown(), diags
	}

	usernameVal, ok := usernameAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`username expected to be basetypes.StringValue, was: %T`, usernameAttribute))
	}

	visibilityAttribute, ok := attributes["visibility"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`visibility is missing from object`)

		return NewOrganizationValueUnknown(), diags
	}

	visibilityVal, ok := visibilityAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`visibility expected to be basetypes.StringValue, was: %T`, visibilityAttribute))
	}

	websiteAttribute, ok := attributes["website"]

	if !ok {
		diags.AddError(
			"Attribute Missing",
			`website is missing from object`)

		return NewOrganizationValueUnknown(), diags
	}

	websiteVal, ok := websiteAttribute.(basetypes.StringValue)

	if !ok {
		diags.AddError(
			"Attribute Wrong Type",
			fmt.Sprintf(`website expected to be basetypes.StringValue, was: %T`, websiteAttribute))
	}

	if diags.HasError() {
		return NewOrganizationValueUnknown(), diags
	}

	return OrganizationValue{
		AvatarUrl:                 avatarUrlVal,
		Description:               descriptionVal,
		Email:                     emailVal,
		FullName:                  fullNameVal,
		Id:                        idVal,
		Location:                  locationVal,
		Name:                      nameVal,
		RepoAdminChangeTeamAccess: repoAdminChangeTeamAccessVal,
		Username:                  usernameVal,
		Visibility:                visibilityVal,
		Website:                   websiteVal,
		state:                     attr.ValueStateKnown,
	}, diags
}

func NewOrganizationValueMust(attributeTypes map[string]attr.Type, attributes map[string]attr.Value) OrganizationValue {
	object, diags := NewOrganizationValue(attributeTypes, attributes)

	if diags.HasError() {
		// This could potentially be added to the diag package.
		diagsStrings := make([]string, 0, len(diags))

		for _, diagnostic := range diags {
			diagsStrings = append(diagsStrings, fmt.Sprintf(
				"%s | %s | %s",
				diagnostic.Severity(),
				diagnostic.Summary(),
				diagnostic.Detail()))
		}

		panic("NewOrganizationValueMust received error(s): " + strings.Join(diagsStrings, "\n"))
	}

	return object
}

func (t OrganizationType) ValueFromTerraform(ctx context.Context, in tftypes.Value) (attr.Value, error) {
	if in.Type() == nil {
		return NewOrganizationValueNull(), nil
	}

	if !in.Type().Equal(t.TerraformType(ctx)) {
		return nil, fmt.Errorf("expected %s, got %s", t.TerraformType(ctx), in.Type())
	}

	if !in.IsKnown() {
		return NewOrganizationValueUnknown(), nil
	}

	if in.IsNull() {
		return NewOrganizationValueNull(), nil
	}

	attributes := map[string]attr.Value{}

	val := map[string]tftypes.Value{}

	err := in.As(&val)

	if err != nil {
		return nil, err
	}

	for k, v := range val {
		a, err := t.AttrTypes[k].ValueFromTerraform(ctx, v)

		if err != nil {
			return nil, err
		}

		attributes[k] = a
	}

	return NewOrganizationValueMust(OrganizationValue{}.AttributeTypes(ctx), attributes), nil
}

func (t OrganizationType) ValueType(ctx context.Context) attr.Value {
	return OrganizationValue{}
}

var _ basetypes.ObjectValuable = OrganizationValue{}

type OrganizationValue struct {
	AvatarUrl                 basetypes.StringValue `tfsdk:"avatar_url"`
	Description               basetypes.StringValue `tfsdk:"description"`
	Email                     basetypes.StringValue `tfsdk:"email"`
	FullName                  basetypes.StringValue `tfsdk:"full_name"`
	Id                        basetypes.Int64Value  `tfsdk:"id"`
	Location                  basetypes.StringValue `tfsdk:"location"`
	Name                      basetypes.StringValue `tfsdk:"name"`
	RepoAdminChangeTeamAccess basetypes.BoolValue   `tfsdk:"repo_admin_change_team_access"`
	Username                  basetypes.StringValue `tfsdk:"username"`
	Visibility                basetypes.StringValue `tfsdk:"visibility"`
	Website                   basetypes.StringValue `tfsdk:"website"`
	state                     attr.ValueState
}

func (v OrganizationValue) ToTerraformValue(ctx context.Context) (tftypes.Value, error) {
	attrTypes := make(map[string]tftypes.Type, 11)

	var val tftypes.Value
	var err error

	attrTypes["avatar_url"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["description"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["email"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["full_name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["id"] = basetypes.Int64Type{}.TerraformType(ctx)
	attrTypes["location"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["name"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["repo_admin_change_team_access"] = basetypes.BoolType{}.TerraformType(ctx)
	attrTypes["username"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["visibility"] = basetypes.StringType{}.TerraformType(ctx)
	attrTypes["website"] = basetypes.StringType{}.TerraformType(ctx)

	objectType := tftypes.Object{AttributeTypes: attrTypes}

	switch v.state {
	case attr.ValueStateKnown:
		vals := make(map[string]tftypes.Value, 11)

		val, err = v.AvatarUrl.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["avatar_url"] = val

		val, err = v.Description.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["description"] = val

		val, err = v.Email.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["email"] = val

		val, err = v.FullName.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["full_name"] = val

		val, err = v.Id.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["id"] = val

		val, err = v.Location.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["location"] = val

		val, err = v.Name.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["name"] = val

		val, err = v.RepoAdminChangeTeamAccess.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["repo_admin_change_team_access"] = val

		val, err = v.Username.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["username"] = val

		val, err = v.Visibility.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["visibility"] = val

		val, err = v.Website.ToTerraformValue(ctx)

		if err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		vals["website"] = val

		if err := tftypes.ValidateValue(objectType, vals); err != nil {
			return tftypes.NewValue(objectType, tftypes.UnknownValue), err
		}

		return tftypes.NewValue(objectType, vals), nil
	case attr.ValueStateNull:
		return tftypes.NewValue(objectType, nil), nil
	case attr.ValueStateUnknown:
		return tftypes.NewValue(objectType, tftypes.UnknownValue), nil
	default:
		panic(fmt.Sprintf("unhandled Object state in ToTerraformValue: %s", v.state))
	}
}

func (v OrganizationValue) IsNull() bool {
	return v.state == attr.ValueStateNull
}

func (v OrganizationValue) IsUnknown() bool {
	return v.state == attr.ValueStateUnknown
}

func (v OrganizationValue) String() string {
	return "OrganizationValue"
}

func (v OrganizationValue) ToObjectValue(ctx context.Context) (basetypes.ObjectValue, diag.Diagnostics) {
	var diags diag.Diagnostics

	attributeTypes := map[string]attr.Type{
		"avatar_url":                    basetypes.StringType{},
		"description":                   basetypes.StringType{},
		"email":                         basetypes.StringType{},
		"full_name":                     basetypes.StringType{},
		"id":                            basetypes.Int64Type{},
		"location":                      basetypes.StringType{},
		"name":                          basetypes.StringType{},
		"repo_admin_change_team_access": basetypes.BoolType{},
		"username":                      basetypes.StringType{},
		"visibility":                    basetypes.StringType{},
		"website":                       basetypes.StringType{},
	}

	if v.IsNull() {
		return types.ObjectNull(attributeTypes), diags
	}

	if v.IsUnknown() {
		return types.ObjectUnknown(attributeTypes), diags
	}

	objVal, diags := types.ObjectValue(
		attributeTypes,
		map[string]attr.Value{
			"avatar_url":                    v.AvatarUrl,
			"description":                   v.Description,
			"email":                         v.Email,
			"full_name":                     v.FullName,
			"id":                            v.Id,
			"location":                      v.Location,
			"name":                          v.Name,
			"repo_admin_change_team_access": v.RepoAdminChangeTeamAccess,
			"username":                      v.Username,
			"visibility":                    v.Visibility,
			"website":                       v.Website,
		})

	return objVal, diags
}

func (v OrganizationValue) Equal(o attr.Value) bool {
	other, ok := o.(OrganizationValue)

	if !ok {
		return false
	}

	if v.state != other.state {
		return false
	}

	if v.state != attr.ValueStateKnown {
		return true
	}

	if !v.AvatarUrl.Equal(other.AvatarUrl) {
		return false
	}

	if !v.Description.Equal(other.Description) {
		return false
	}

	if !v.Email.Equal(other.Email) {
		return false
	}

	if !v.FullName.Equal(other.FullName) {
		return false
	}

	if !v.Id.Equal(other.Id) {
		return false
	}

	if !v.Location.Equal(other.Location) {
		return false
	}

	if !v.Name.Equal(other.Name) {
		return false
	}

	if !v.RepoAdminChangeTeamAccess.Equal(other.RepoAdminChangeTeamAccess) {
		return false
	}

	if !v.Username.Equal(other.Username) {
		return false
	}

	if !v.Visibility.Equal(other.Visibility) {
		return false
	}

	if !v.Website.Equal(other.Website) {
		return false
	}

	return true
}

func (v OrganizationValue) Type(ctx context.Context) attr.Type {
	return OrganizationType{
		basetypes.ObjectType{
			AttrTypes: v.AttributeTypes(ctx),
		},
	}
}

func (v OrganizationValue) AttributeTypes(ctx context.Context) map[string]attr.Type {
	return map[string]attr.Type{
		"avatar_url":                    basetypes.StringType{},
		"description":                   basetypes.StringType{},
		"email":                         basetypes.StringType{},
		"full_name":                     basetypes.StringType{},
		"id":                            basetypes.Int64Type{},
		"location":                      basetypes.StringType{},
		"name":                          basetypes.StringType{},
		"repo_admin_change_team_access": basetypes.BoolType{},
		"username":                      basetypes.StringType{},
		"visibility":                    basetypes.StringType{},
		"website":                       basetypes.StringType{},
	}
}
